<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>N‑Body Playground — v7.7.1 (Standalone)</title>
<style>
  :root{ --bg:#0b1020; --text:#e6ebff; --muted:#8ea0d0; --accent:#6aa6ff; }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
  #wrap{display:grid;grid-template-columns:380px 1fr;height:100vh}
  #controls{background:linear-gradient(180deg,#0f1530 0%,#0b1020 100%);border-right:1px solid #1f2a4d;padding:14px;overflow:auto}
  h1{font-size:18px;margin:6px 0}
  h2{font-size:12px;font-weight:700;margin:14px 0 6px;color:var(--muted);letter-spacing:.08em;text-transform:uppercase}
  label{display:flex;align-items:center;gap:8px;font-size:14px;margin:8px 0}
  input[type="range"], select{width:100%}
  input[type="number"]{width:100%;padding:6px;border:1px solid #33406b;border-radius:6px;background:#0c1430;color:#e6ebff}
  .row{display:flex;gap:8px;align-items:center}
  .row>*{flex:1}
  .btn{display:inline-flex;align-items:center;justify-content:center;gap:6px;padding:8px 10px;margin:4px 0;border:1px solid #33406b;border-radius:8px;background:#0c1430;color:#e6ebff;text-decoration:none;cursor:pointer;user-select:none}
  .btn.primary{background:linear-gradient(180deg,#1b2a66,#132558);border-color:#4054a8;color:#fff}
  .small{font-size:12px;color:#8ea0d0;line-height:1.4}
  #diag{background:#0c1430;border:1px solid #2a3a7a;border-radius:8px;padding:8px;max-height:160px;overflow:auto;font-size:12px;color:#cde;white-space:pre-wrap}
  #main{position:relative}
  #canvas{width:100%;height:100%;display:block}
  #overlay{position:absolute;right:12px;top:12px;z-index:5;padding:6px 8px;border-radius:8px;background:#141b36cc;border:1px solid #2a3a7a;color:#c9d4ff;font-size:12px;pointer-events:none}
  .pill{display:inline-block;padding:2px 6px;border:1px solid #2a3a7a;border-radius:999px;background:#0e1640;color:#cfe2ff;margin-right:6px}
</style>
</head>
<body>
<div id="wrap">
  <aside id="controls">
    <h1>N‑Body Playground (3D)</h1>

    <h2>Setup</h2>
    <div class="row">
      <label class="row"><span>N</span><input id="nBodies" type="number" min="50" max="2000" step="50" value="800"></label>
      <label class="row"><span>Seed</span><input id="seed" type="number" min="0" max="999999" step="1" value="42"></label>
    </div>
    <div class="row">
      <label class="row"><span>Mass min</span><input id="mMin" type="number" min="0.05" step="0.05" value="0.2"></label>
      <label class="row"><span>Mass max</span><input id="mMax" type="number" min="0.05" step="0.05" value="3.0"></label>
    </div>
    <label class="row"><span>Spawn radius</span><input id="spawnR" type="range" min="0.05" max="3.0" step="0.01" value="1.4"></label>
    <label class="row"><span>Cloud: start stationary</span><input id="cloudStill" type="checkbox" checked></label>

    <h2>Physics</h2>
    <div class="row">
      <label class="row"><span>G</span><input id="G" type="number" step="0.0001" value="1"></label>
      <label class="row"><span>Δt</span><input id="dt" type="number" step="0.0005" value="0.01"></label>
    </div>
    <div class="row">
      <label class="row"><span>Softening ε</span><input id="eps" type="number" step="0.0005" value="0.02"></label>
      <label class="row"><span>Speed ×</span><input id="speed" type="range" min="0.25" max="8" step="0.25" value="1.5"></label>
    </div>

    <h2>Rendering</h2>
    <div class="row">
      <label class="row"><span>Base point size</span><input id="radius" type="range" min="1" max="8" step="0.5" value="4.0"></label>
      <label class="row"><span>Glow</span><input id="glow" type="checkbox" checked></label>
    </div>

    <h2>Camera</h2>
    <div class="small">
      <div><span class="pill">Drag</span> rotate • <span class="pill">Right/Shift‑drag</span> pan • <span class="pill">Wheel/Pinch</span> zoom • <span class="pill">Double‑click</span> reset • <span class="pill">A</span>uto‑fit</div>
      <div>Az/El/Dist: <span id="camTxt">—</span></div>
    </div>

    <div class="row" style="margin-top:10px">
      <button id="btnStart" class="btn primary">▶ Start</button>
      <button id="btnPause" class="btn">⏸ Pause</button>
      <button id="btnReset" class="btn">⟲ Reset</button>
      <button id="btnFit" class="btn">⤢ Auto‑fit</button>
    </div>

    <h2>Diagnostics</h2>
    <div id="diag" class="small">Booting…</div>
  </aside>

  <main id="main">
    <div id="overlay">Running… (Space to pause)</div>
    <canvas id="canvas"></canvas>
  </main>
</div>

<script>
(function(){
  'use strict';
  const VERSION='v7.7.1-standalone';
  const overlay = document.getElementById('overlay');
  const diag = document.getElementById('diag');
  function log(msg){ const t=new Date().toLocaleTimeString(); diag.textContent += `\\n[${t}] ${msg}`; diag.scrollTop = diag.scrollHeight; }

  const $=id=>document.getElementById(id);
  const ctl={
    nBodies:$('nBodies'), seed:$('seed'), mMin:$('mMin'), mMax:$('mMax'), spawnR:$('spawnR'), cloudStill:$('cloudStill'),
    G:$('G'), dt:$('dt'), eps:$('eps'), speed:$('speed'),
    radius:$('radius'), glow:$('glow'),
    btnStart:$('btnStart'), btnPause:$('btnPause'), btnReset:$('btnReset'), btnFit:$('btnFit'),
    camTxt:$('camTxt')
  };

  // WebGL init
  const canvas=$('canvas'), main=document.getElementById('main');
  /** @type {WebGLRenderingContext} */
  let gl = canvas.getContext('webgl', {antialias:true, alpha:false, preserveDrawingBuffer:false});
  if(!gl){ gl = canvas.getContext('experimental-webgl'); }
  if(!gl){ log(VERSION+' — WebGL not available'); return; }
  log(VERSION+' — WebGL OK: '+gl.getParameter(gl.VERSION));

  // Resize
  function ensureSize(){ const dpr=Math.max(1,window.devicePixelRatio||1); const rect=canvas.getBoundingClientRect(); const w=Math.max(2,Math.floor(rect.width*dpr)); const h=Math.max(2,Math.floor(rect.height*dpr)); if(canvas.width!==w||canvas.height!==h){ canvas.width=w; canvas.height=h; gl.viewport(0,0,w,h); } }
  function fullResize(){ main.style.transform='translateZ(0)'; void main.offsetHeight; main.style.transform=''; ensureSize(); }
  fullResize(); window.addEventListener('resize', fullResize);

  // Shaders
  function makeProgram(vsSrc,fsSrc){
    const vs=gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs,vsSrc); gl.compileShader(vs); if(!gl.getShaderParameter(vs, gl.COMPILE_STATUS)){ log('VS error: '+gl.getShaderInfoLog(vs)); throw new Error('VS'); }
    const fs=gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs,fsSrc); gl.compileShader(fs); if(!gl.getShaderParameter(fs, gl.COMPILE_STATUS)){ log('FS error: '+gl.getShaderInfoLog(fs)); throw new Error('FS'); }
    const p=gl.createProgram(); gl.attachShader(p,vs); gl.attachShader(p,fs); gl.linkProgram(p); if(!gl.getProgramParameter(p, gl.LINK_STATUS)){ log('LINK error: '+gl.getProgramInfoLog(p)); throw new Error('LINK'); } return p;
  }

  const vsPoints = `
    attribute vec3 a_pos;
    attribute vec3 a_col;
    attribute float a_size;
    uniform mat4 u_mvp;
    uniform float u_pointSize;
    varying vec3 vcol;
    void main(){
      vec4 p=u_mvp*vec4(a_pos,1.0);
      gl_Position=p;
      gl_PointSize=u_pointSize * a_size;
      vcol=a_col;
    }`;

  const fsPoints = `
    precision mediump float;
    varying vec3 vcol;
    uniform bool u_glow;
    void main(){
      vec2 uv=gl_PointCoord*2.0-1.0;
      float r2=dot(uv,uv);
      if(r2>1.0) discard;
      float core=smoothstep(0.20,0.0,r2);
      float edge=smoothstep(1.0,0.25,r2);
      float halo = u_glow ? smoothstep(1.0,0.0,r2)*0.35 : 0.0;
      vec3 col = mix(vcol*0.85,vcol,core) + vec3(1.0,0.95,0.8)*0.20*core + halo*vec3(0.8,0.9,1.0);
      gl_FragColor=vec4(col, edge);
    }`;

  const prog = makeProgram(vsPoints, fsPoints);
  const loc = {
    a_pos: gl.getAttribLocation(prog,'a_pos'),
    a_col: gl.getAttribLocation(prog,'a_col'),
    a_size: gl.getAttribLocation(prog,'a_size'),
    u_mvp: gl.getUniformLocation(prog,'u_mvp'),
    u_pointSize: gl.getUniformLocation(prog,'u_pointSize'),
    u_glow: gl.getUniformLocation(prog,'u_glow')
  };

  // Buffers
  const posBuf = gl.createBuffer();
  const colBuf = gl.createBuffer();
  const sizeBuf = gl.createBuffer();

  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  gl.clearColor(0.03,0.05,0.12,1);

  // Matrices (minimal)
  function mat4_identity(){ return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]; }
  function mat4_mul(a,b){ const o=new Float32Array(16); for(let i=0;i<4;i++) for(let j=0;j<4;j++){ o[i*4+j]=a[i*4+0]*b[0*4+j]+a[i*4+1]*b[1*4+j]+a[i*4+2]*b[2*4+j]+a[i*4+3]*b[3*4+j]; } return o; }
  function mat4_perspective(fovy,aspect,near,far){ const f=1/Math.tan(fovy/2), nf=1/(near-far); return new Float32Array([f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,(2*far*near)*nf,0]); }
  function mat4_translate(m,x,y,z){ const t=mat4_identity(); t[12]=x; t[13]=y; t[14]=z; return mat4_mul(m,t); }
  function mat4_rotateY(m,a){ const c=Math.cos(a), s=Math.sin(a); const r=[c,0,s,0, 0,1,0,0, -s,0,c,0, 0,0,0,1]; return mat4_mul(m,r); }
  function mat4_rotateX(m,a){ const c=Math.cos(a), s=Math.sin(a); const r=[1,0,0,0, 0,c,-s,0, 0,s,c,0, 0,0,0,1]; return mat4_mul(m,r); }
  function cameraMVP(){ ensureSize(); const w=canvas.width,h=canvas.height,aspect=w/Math.max(1,h); let P=mat4_perspective(50*Math.PI/180,aspect,0.05,500.0); let V=mat4_identity(); V=mat4_rotateX(V,world.cam.elevation); V=mat4_rotateY(V,world.cam.azimuth); V=mat4_translate(V,-world.cam.panX,-world.cam.panY,-world.cam.distance); return mat4_mul(P,V); }

  // Data & physics
  const MAXN=2000;
  const pos = new Float32Array(3*MAXN);
  const col = new Float32Array(3*MAXN);
  const siz = new Float32Array(MAXN);
  const palette=[[0.64,0.72,1],[0.62,0.89,1],[1,0.83,0.5],[1,0.62,0.7],[0.84,1,0.62],[0.78,0.66,1],[0.62,1,0.85]];
  const pick=i=>palette[i%palette.length];
  function seeded(seed){ let a=(seed>>>0)||1; return ()=>{ a|=0; a=a+0x6D2B79F5|0; let t=Math.imul(a^a>>>15,a|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; }; }

  const bodies=[]; // array of objects {x,y,z,vx,vy,vz,m,color[3]}
  const world={ step:0, paused:false, cam:{ azimuth:0.4, elevation:0.35, distance:6.0, panX:0, panY:0 } };

  function createCloud(){
    bodies.length=0;
    const n=Math.min(MAXN, Math.max(1, parseInt(ctl.nBodies.value,10)||800));
    const mMin=parseFloat(ctl.mMin.value)||0.2, mMax=parseFloat(ctl.mMax.value)||3.0, R=parseFloat(ctl.spawnR.value)||1.4;
    const rnd=seeded(parseInt(ctl.seed.value,10)||42);
    const still = ctl.cloudStill.checked;
    for(let i=0;i<n;i++){
      const r=R*Math.pow(rnd(),1/3);
      const th=Math.acos(1-2*rnd());
      const ph=2*Math.PI*rnd();
      const x=r*Math.sin(th)*Math.cos(ph), y=r*Math.sin(th)*Math.sin(ph), z=r*Math.cos(th);
      const m=mMin+(mMax-mMin)*Math.pow(rnd(),0.6);
      const vx = still?0:(rnd()-0.5)*0.12;
      const vy = still?0:(rnd()-0.5)*0.12;
      const vz = still?0:(rnd()-0.5)*0.12;
      const c=pick(i);
      bodies.push({x,y,z,vx,vy,vz,m,color:c});
    }
    uploadBuffers();
    autoFit();
  }

  function uploadBuffers(){
    const n=bodies.length;
    let minM=Infinity, maxM=-Infinity;
    for(let i=0;i<n;i++){ const m=bodies[i].m; if(m<minM) minM=m; if(m>maxM) maxM=m; }
    const span=Math.max(1e-6, maxM-minM);
    for(let i=0;i<n;i++){
      const b=bodies[i];
      pos[i*3]=b.x; pos[i*3+1]=b.y; pos[i*3+2]=b.z;
      col[i*3]=b.color[0]; col[i*3+1]=b.color[1]; col[i*3+2]=b.color[2];
      const t=(b.m-minM)/span;
      siz[i]=0.75 + 1.75*t; // 1x..2.5x visual scaling
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, posBuf); gl.bufferData(gl.ARRAY_BUFFER, pos.subarray(0, n*3), gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, colBuf); gl.bufferData(gl.ARRAY_BUFFER, col.subarray(0, n*3), gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuf); gl.bufferData(gl.ARRAY_BUFFER, siz.subarray(0, n), gl.DYNAMIC_DRAW);
  }

  function computeAccelerations(G,eps2){
    const n=bodies.length;
    for(let i=0;i<n;i++){ bodies[i].ax=0; bodies[i].ay=0; bodies[i].az=0; }
    for(let i=0;i<n;i++){
      const bi=bodies[i];
      for(let j=i+1;j<n;j++){
        const bj=bodies[j];
        const dx=bj.x-bi.x, dy=bj.y-bi.y, dz=bj.z-bi.z;
        const r2=dx*dx+dy*dy+dz*dz+eps2;
        const invR=1/Math.sqrt(r2), invR3=invR*invR*invR;
        const f=G*invR3;
        const fx=f*dx, fy=f*dy, fz=f*dz;
        bi.ax += fx * bj.m; bi.ay += fy * bj.m; bi.az += fz * bj.m;
        bj.ax -= fx * bi.m; bj.ay -= fy * bi.m; bj.az -= fz * bi.m;
      }
    }
  }

  function stepSystem(){
    const G=parseFloat(ctl.G.value)||1;
    const eps2=Math.pow(parseFloat(ctl.eps.value)||0.02,2);
    const dt=(parseFloat(ctl.dt.value)||0.02) * (parseFloat(ctl.speed.value)||1);
    const n=bodies.length;
    for(let i=0;i<n;i++){ const b=bodies[i]; b.vx += 0.5*dt*(b.ax||0); b.vy += 0.5*dt*(b.ay||0); b.vz += 0.5*dt*(b.az||0); b.x += dt*b.vx; b.y += dt*b.vy; b.z += dt*b.vz; }
    computeAccelerations(G,eps2);
    for(let i=0;i<n;i++){ const b=bodies[i]; b.vx += 0.5*dt*b.ax; b.vy += 0.5*dt*b.ay; b.vz += 0.5*dt*b.az; }
    world.step++;
  }

  function render(){
    ensureSize();
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(prog);
    const mvp=cameraMVP();
    gl.uniformMatrix4fv(loc.u_mvp,false,mvp);
    gl.uniform1f(loc.u_pointSize, parseFloat(ctl.radius.value)||4);
    gl.uniform1i(loc.u_glow, ctl.glow.checked?1:0);

    gl.bindBuffer(gl.ARRAY_BUFFER, posBuf); gl.enableVertexAttribArray(loc.a_pos); gl.vertexAttribPointer(loc.a_pos,3,gl.FLOAT,false,0,0);
    gl.bindBuffer(gl.ARRAY_BUFFER, colBuf); gl.enableVertexAttribArray(loc.a_col); gl.vertexAttribPointer(loc.a_col,3,gl.FLOAT,false,0,0);
    gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuf); gl.enableVertexAttribArray(loc.a_size); gl.vertexAttribPointer(loc.a_size,1,gl.FLOAT,false,0,0);
    gl.drawArrays(gl.POINTS, 0, bodies.length);
  }

  // Camera & controls
  (function controls(){
    const c=world.cam;
    const state={down:false, right:false, lastX:0,lastY:0};
    function updateTxt(){ ctl.camTxt.textContent = `${(c.azimuth*180/Math.PI)|0}° / ${(c.elevation*180/Math.PI)|0}° / ${c.distance.toFixed(2)}`; }
    canvas.addEventListener('mousedown',e=>{ state.down=true; state.right=(e.button===2)||e.shiftKey; state.lastX=e.clientX; state.lastY=e.clientY; e.preventDefault(); });
    window.addEventListener('mouseup',()=>{ state.down=false; });
    window.addEventListener('mousemove',e=>{
      if(!state.down) return;
      const dx=e.clientX-state.lastX, dy=e.clientY-state.lastY; state.lastX=e.clientX; state.lastY=e.clientY;
      if(state.right){ c.panX -= dx*0.001*c.distance; c.panY += dy*0.001*c.distance; }
      else { c.azimuth += dx*0.005; c.elevation = Math.max(-Math.PI/2+0.01, Math.min(Math.PI/2-0.01, c.elevation+dy*0.005)); }
      updateTxt();
    });
    canvas.addEventListener('wheel',e=>{ e.preventDefault(); c.distance = Math.max(0.5, Math.min(300, c.distance * Math.exp(e.deltaY*0.001))); updateTxt(); }, {passive:false});
    canvas.addEventListener('dblclick',()=>{ c.azimuth=0.4; c.elevation=0.35; c.distance=fitDistance(); c.panX=0; c.panY=0; updateTxt(); });
    canvas.addEventListener('contextmenu',e=>e.preventDefault());
    updateTxt();
  })();

  function computeBounds(){
    if(!bodies.length) return {r:1,cx:0,cy:0,cz:0};
    let cx=0,cy=0,cz=0; for(const p of bodies){ cx+=p.x; cy+=p.y; cz+=p.z; } cx/=bodies.length; cy/=bodies.length; cz/=bodies.length;
    let r=0; for(const p of bodies){ const dx=p.x-cx, dy=p.y-cy, dz=p.z-cz; const d=Math.sqrt(dx*dx+dy*dy+dz*dz); if(d>r) r=d; }
    return {r:Math.max(0.1,r), cx, cy, cz};
  }
  function fitDistance(){ const {r}=computeBounds(); const fovy=50*Math.PI/180; const margin=1.3; return r*margin/Math.tan(fovy/2)+0.5; }
  function autoFit(){ const {cx,cy}=computeBounds(); world.cam.distance = fitDistance(); world.cam.panX=cx; world.cam.panY=-cy; }

  // Loop
  function loop(){
    requestAnimationFrame(loop);
    if(!world.paused){ stepSystem(); if(world.step%2===0) uploadBuffers(); }
    render();
  }

  // Wire UI
  ctl.btnStart.addEventListener('click',()=>{ world.paused=false; overlay.textContent='Running… (Space to pause)'; });
  ctl.btnPause.addEventListener('click',()=>{ world.paused=!world.paused; overlay.textContent = world.paused?'Paused (Space to resume)':'Running… (Space to pause)'; ctl.btnPause.textContent = world.paused?'⏵ Resume':'⏸ Pause'; });
  ctl.btnReset.addEventListener('click',()=>{ createCloud(); overlay.textContent='Running… (Space to pause)'; });
  ctl.btnFit.addEventListener('click',autoFit);
  window.addEventListener('keydown',e=>{ if(e.code==='Space'){ e.preventDefault(); ctl.btnPause.click(); } if(e.key==='a'||e.key==='A'){ autoFit(); }});
  ['nBodies','seed','mMin','mMax','spawnR','G','dt','eps','cloudStill'].forEach(id=>$(id).addEventListener('change', createCloud));
  ['speed','radius','glow'].forEach(id=>$(id).addEventListener('input', ()=>{}));

  // Boot
  createCloud();
  loop();
  log(VERSION+' — Ready.');
})();
</script>
</body>
</html>
