<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>N-Body Playground by Steve Cullen and ChatGPT (v2.0.3)</title>
<style>
  html, body { margin:0; height:100%; background:#0b0f16; color:#e6eef8; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
  #topbar { position:fixed; top:0; left:0; right:0; display:flex; align-items:center; gap:16px; padding:10px 12px; background:#0d1628; border-bottom:1px solid #1a2b4a; z-index:20; }
  #title { font-weight:700; letter-spacing:.3px; }
  #status { font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space:pre; opacity:.9; }
  #app { position:fixed; inset:46px 0 0 0; display:grid; grid-template-columns:320px 1fr 360px; }
  #left, #right { background:#0e1320; border-right:1px solid #1a2235; overflow:auto; }
  #right { border-left:1px solid #1a2235; border-right:none; }
  #viewport { position:relative; }
  .panel { padding:12px; }
  h2 { margin:8px 0 6px; font-size:16px; letter-spacing:.3px; color:#b9d2ff }
  .group { margin:8px 0 14px; padding:10px; background:#0b1120; border:1px solid #1a2235; border-radius:8px; }
  .row { display:grid; grid-template-columns: 1fr 100px; gap:8px; align-items:center; margin:6px 0; }
  .row label { font-size:13px; color:#cfe0ff; }
  .row input[type="range"] { width:100%; }
  .row input[type="number"], .row select { width:100%; padding:6px; background:#0f1526; border:1px solid #28365a; color:#e6eef8; border-radius:6px; }
  .buttons { display:flex; gap:8px; flex-wrap:wrap; }
  button { padding:8px 10px; border-radius:8px; border:1px solid #33466f; background:#13203a; color:#e6eef8; cursor:pointer; }
  button.primary { border-color:#4a83ff; background:#1a2f5c; }
  .hint { font-size:12px; color:#9fb4db; margin-top:6px; }
  #chartWrap { position:absolute; left:12px; bottom:12px; width:520px; background:#0d1322c0; border:1px solid #1a2235; border-radius:8px; padding:8px; backdrop-filter: blur(4px); }
  #chart { width:100%; height:140px; display:block; background:#0c111d; border-radius:6px; }
  #legend { display:flex; gap:12px; font-size:12px; margin:6px 2px 0; color:#c9d8f4; opacity:.9; }
  #legend span::before { content:""; display:inline-block; width:10px; height:10px; margin-right:6px; border-radius:2px; vertical-align:baseline; }
  #legK::before { background:#6fc2ff; }
  #legU::before { background:#f6d06f; }
  #legT::before { background:#a9f56f; }
  #metrics { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; line-height:1.35; white-space:pre-wrap; }
  canvas { display:block; }
  #trailCanvas { position:absolute; inset:0; pointer-events:none; }
</style>
</head>
<body>
<div id="topbar">
  <div id="title">N-Body Playground by Steve Cullen and ChatGPT (v2.0.3)</div>
  <div id="status">Booting…</div>
</div>

<div id="app">
  <div id="left" class="panel">
    <h2>Setup</h2>
    <div class="group">
      <div class="row"><label>Stars (N)</label><input id="nStars" type="range" min="50" max="3000" step="50" value="800"><input id="nStarsNum" type="number" min="50" max="3000" step="50" value="800"></div>
      <div class="row"><label>Init radius (AU)</label><input id="radiusAU" type="range" min="0.2" max="50" step="0.1" value="6"><input id="radiusAUNum" type="number" min="0.2" max="50" step="0.1" value="6"></div>
      <div class="row"><label>Init velocity (km/s)</label><input id="initV" type="range" min="0" max="80" step="1" value="0"><input id="initVNum" type="number" min="0" max="80" step="1" value="0"></div>
      <div class="row"><label>Star mass min (M☉)</label><input id="mMin" type="range" min="1e-6" max="1" step="1e-6" value="5e-5"><input id="mMinNum" type="number" step="1e-6" value="5e-5"></div>
      <div class="row"><label>Star mass max (M☉)</label><input id="mMax" type="range" min="1e-6" max="5" step="1e-6" value="1e-3"><input id="mMaxNum" type="number" step="1e-6" value="1e-3"></div>
    </div>

    <h2>Central Star</h2>
    <div class="group">
      <div class="row"><label>Mass (M☉)</label><input id="mCentral" type="range" min="0.1" max="50" step="0.1" value="1"><input id="mCentralNum" type="number" min="0.1" max="50" step="0.1" value="1"></div>
      <div class="row"><label>Glow</label>
        <select id="glowMode">
          <option value="off">Off</option>
          <option value="on" selected>On</option>
        </select>
        <input id="glowIntensity" type="range" min="0" max="1" step="0.01" value="0.6">
      </div>
    </div>

    <h2>Collisions</h2>
    <div class="group">
      <div class="row"><label>Collision mode</label>
        <select id="collisionMode">
          <option value="none" selected>None</option>
          <option value="elastic">Elastic</option>
          <option value="merge">Merge</option>
        </select>
      </div>
      <div class="row"><label>Softening (ε)</label><input id="softening" type="range" min="0" max="0.2" step="0.001" value="0.01"><input id="softeningNum" type="number" min="0" max="0.2" step="0.001" value="0.01"></div>
    </div>

    <h2>Trails</h2>
    <div class="group">
      <div class="row"><label>Preset</label>
        <select id="trailPreset">
          <option value="none">None</option>
          <option value="short">Short</option>
          <option value="long" selected>Long</option>
          <option value="ultra">Ultra</option>
        </select>
      </div>
      <div class="row"><label>Persistence (s)</label><input id="trailSeconds" type="range" min="0" max="60" step="1" value="20"><input id="trailSecondsNum" type="number" min="0" max="60" step="1" value="20"></div>
    </div>

    <div class="buttons">
      <button id="btnReset">Reset</button>
      <button id="btnStart" class="primary">Start</button>
      <button id="btnPause">Pause</button>
      <button id="btnClear">Clear Trails</button>
      <button id="btnAutoFit">Auto Fit</button>
    </div>

    <div class="hint">Trackball: drag=rotate, right‑drag=pan, wheel=zoom.</div>
  </div>

  <div id="viewport">
    <canvas id="trailCanvas"></canvas>
    <div id="chartWrap">
      <canvas id="chart"></canvas>
      <div id="legend"><span id="legK">Kinetic</span><span id="legU">Potential</span><span id="legT">Total</span></div>
    </div>
  </div>

  <div id="right" class="panel">
    <h2>Metrics</h2>
    <div class="group"><div id="metrics">—</div></div>
  </div>
</div>

<script>
// Boot/diagnostics & dynamic loader
(function(){
  const statusEl = document.getElementById('status');
  function setStatus(msg, err){ statusEl.textContent = msg; statusEl.style.color = err ? '#ff7b7b' : ''; }
  function webglOK(){ const c=document.createElement('canvas'); const gl=c.getContext('webgl')||c.getContext('experimental-webgl'); return !!gl; }
  if(!webglOK()){ setStatus('❌ WebGL not supported'); return; }
  setStatus('✅ WebGL OK — loading Three.js…');
  function load(u){ return new Promise((res,rej)=>{ const s=document.createElement('script'); s.src=u; s.onload=()=>res(u); s.onerror=()=>rej(u); document.head.appendChild(s); }); }
  load('https://unpkg.com/three@0.150.1/build/three.min.js')
  .then(()=>{ setStatus('✅ Three.js loaded — loading TrackballControls…'); } ).then(()=>{ setStatus('✅ Controls loaded — initializing…'); THREE=window.THREE; 
// Inlined TrackballControls (Three.js r136)
THREE.TrackballControls = function ( object, domElement ) {
  var _this = this;
  var STATE = { NONE: - 1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };
  this.object = object;
  this.domElement = ( domElement !== undefined ) ? domElement : document;
  this.enabled = true;
  this.screen = { left: 0, top: 0, width: 0, height: 0 };
  this.rotateSpeed = 1.0;
  this.zoomSpeed = 1.2;
  this.panSpeed = 0.3;
  this.noRotate = false;
  this.noZoom = false;
  this.noPan = false;
  this.staticMoving = false;
  this.dynamicDampingFactor = 0.2;
  this.minDistance = 0;
  this.maxDistance = Infinity;
  this.keys = [ 65, 83, 68 ];
  this.target = new THREE.Vector3();
  var EPS = 0.000001;
  var lastPosition = new THREE.Vector3();
  var lastZoom = 1;
  var _state = STATE.NONE,
    _prevState = STATE.NONE,
    _eye = new THREE.Vector3(),
    _movePrev = new THREE.Vector2(),
    _moveCurr = new THREE.Vector2(),
    _lastAxis = new THREE.Vector3(),
    _lastAngle = 0,
    _zoomStart = new THREE.Vector2(),
    _zoomEnd = new THREE.Vector2(),
    _touchZoomDistanceStart = 0,
    _touchZoomDistanceEnd = 0,
    _panStart = new THREE.Vector2(),
    _panEnd = new THREE.Vector2();
  this.handleResize = function () {
    if ( this.domElement === document ) {
      this.screen.left = 0;
      this.screen.top = 0;
      this.screen.width = window.innerWidth;
      this.screen.height = window.innerHeight;
    } else {
      var box = this.domElement.getBoundingClientRect();
      var d = this.domElement.ownerDocument.documentElement;
      this.screen.left = box.left + window.pageXOffset - d.clientLeft;
      this.screen.top = box.top + window.pageYOffset - d.clientTop;
      this.screen.width = box.width;
      this.screen.height = box.height;
    }
  };
  var getMouseOnScreen = ( function () {
    var vector = new THREE.Vector2();
    return function getMouseOnScreen( pageX, pageY ) {
      vector.set(
        ( pageX - _this.screen.left ) / _this.screen.width,
        ( pageY - _this.screen.top ) / _this.screen.height
      );
      return vector;
    };
  }() );
  var getMouseOnCircle = ( function () {
    var vector = new THREE.Vector2();
    return function getMouseOnCircle( pageX, pageY ) {
      vector.set(
        ( ( pageX - _this.screen.width * 0.5 - _this.screen.left ) / (_this.screen.width*0.5) ),
        ( ( _this.screen.height + 2 * ( _this.screen.top - pageY ) ) / _this.screen.width )
      );
      return vector;
    };
  }() );
  this.rotateCamera = ( function () {
    var axis = new THREE.Vector3(),
      quaternion = new THREE.Quaternion(),
      eyeDirection = new THREE.Vector3(),
      objectUpDirection = new THREE.Vector3(),
      objectSidewaysDirection = new THREE.Vector3(),
      moveDirection = new THREE.Vector3(),
      angle;
    return function rotateCamera() {
      moveDirection.set( _moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0 );
      angle = moveDirection.length();
      if ( angle ) {
        _eye.copy( _this.object.position ).sub( _this.target );
        eyeDirection.copy( _eye ).normalize();
        objectUpDirection.copy( _this.object.up ).normalize();
        objectSidewaysDirection.crossVectors( objectUpDirection, eyeDirection ).normalize();
        objectUpDirection.setLength( _moveCurr.y - _movePrev.y );
        objectSidewaysDirection.setLength( _moveCurr.x - _movePrev.x );
        moveDirection.copy( objectUpDirection.add( objectSidewaysDirection ) );
        axis.crossVectors( moveDirection, _eye ).normalize();
        angle *= _this.rotateSpeed;
        quaternion.setFromAxisAngle( axis, angle );
        _eye.applyQuaternion( quaternion );
        _this.object.up.applyQuaternion( quaternion );
        _lastAxis.copy( axis );
        _lastAngle = angle;
      } else if ( !_this.staticMoving && _lastAngle ) {
        _lastAngle *= Math.sqrt( 1.0 - _this.dynamicDampingFactor );
        _eye.copy( _this.object.position ).sub( _this.target );
        quaternion.setFromAxisAngle( _lastAxis, _lastAngle );
        _eye.applyQuaternion( quaternion );
        _this.object.up.applyQuaternion( quaternion );
      }
      _movePrev.copy( _moveCurr );
    };
  }() );
  this.zoomCamera = function () {
    var factor;
    if ( _state === STATE.TOUCH_ZOOM_PAN ) {
      factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
      _touchZoomDistanceStart = _touchZoomDistanceEnd;
      _eye.multiplyScalar( factor );
    } else {
      factor = 1.0 + ( _zoomEnd.y - _zoomStart.y ) * _this.zoomSpeed;
      if ( factor !== 1.0 && factor > 0.0 ) {
        _eye.multiplyScalar( factor );
        if ( _this.staticMoving ) {
          _zoomStart.copy( _zoomEnd );
        } else {
          _zoomStart.y += ( _zoomEnd.y - _zoomStart.y ) * this.dynamicDampingFactor;
        }
      }
    }
  };
  this.panCamera = ( function () {
    var mouseChange = new THREE.Vector2(),
      objectUp = new THREE.Vector3(),
      pan = new THREE.Vector3();
    return function panCamera() {
      mouseChange.copy( _panEnd ).sub( _panStart );
      if ( mouseChange.lengthSq() ) {
        mouseChange.multiplyScalar( _eye.length() * _this.panSpeed );
        pan.copy( _eye ).cross( _this.object.up ).setLength( mouseChange.x );
        pan.add( objectUp.copy( _this.object.up ).setLength( mouseChange.y ) );
        _this.object.position.add( pan );
        _this.target.add( pan );
        if ( _this.staticMoving ) {
          _panStart.copy( _panEnd );
        } else {
          _panStart.add( mouseChange.subVectors( _panEnd, _panStart ).multiplyScalar( _this.dynamicDampingFactor ) );
        }
      }
    };
  }() );
  this.update = function () {
    _eye.subVectors( _this.object.position, _this.target );
    if ( !_this.noRotate ) { _this.rotateCamera(); }
    if ( !_this.noZoom ) { _this.zoomCamera(); }
    if ( !_this.noPan ) { _this.panCamera(); }
    _this.object.position.addVectors( _this.target, _eye );
    _this.object.lookAt( _this.target );
  };
  function keydown( event ) { if ( _this.enabled === false ) return; _prevState = _state; if ( _state !== STATE.NONE ) { return; } else if ( event.keyCode === _this.keys[ STATE.ROTATE ] ) { _state = STATE.ROTATE; } else if ( event.keyCode === _this.keys[ STATE.ZOOM ] ) { _state = STATE.ZOOM; } else if ( event.keyCode === _this.keys[ STATE.PAN ] ) { _state = STATE.PAN; } }
  function keyup( event ) { if ( _this.enabled === false ) return; _state = _prevState; }
  this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
  this.domElement.addEventListener( 'mousedown', function ( event ) { if ( _this.enabled === false ) return; event.preventDefault(); event.stopPropagation(); if ( _state === STATE.NONE ) { _state = event.button; } _moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) ); _movePrev.copy( _moveCurr ); document.addEventListener( 'mousemove', mousemove, false ); document.addEventListener( 'mouseup', mouseup, false ); }, false );
  function mousemove( event ) { if ( _this.enabled === false ) return; event.preventDefault(); event.stopPropagation(); _movePrev.copy( _moveCurr ); _moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) ); }
  function mouseup( event ) { if ( _this.enabled === false ) return; event.preventDefault(); event.stopPropagation(); _state = STATE.NONE; document.removeEventListener( 'mousemove', mousemove ); document.removeEventListener( 'mouseup', mouseup ); }
};
 startApp(); })
  .then(()=>{ setStatus('✅ Controls loaded — initializing…'); startApp(); })
  .catch(u=>{ setStatus('⚠️ Failed to load: '+u, true); });
  
  function startApp(){
    const AU=1.496e11, MSUN=1.989e30, G=6.67430e-11;
    const $ = id=>document.getElementById(id);
    const state = {
      n: parseInt($('nStars').value,10),
      radiusAU: parseFloat($('radiusAU').value),
      initV_kms: parseFloat($('initV').value),
      mMinMSun: parseFloat($('mMin').value),
      mMaxMSun: parseFloat($('mMax').value),
      softening: parseFloat($('softening').value),
      collisionMode: $('collisionMode').value,
      trailSeconds: parseFloat($('trailSeconds').value),
      glow: $('glowMode').value==='on',
      glowIntensity: parseFloat($('glowIntensity').value),
      running:false, timeScale:1500, subDt:0.02
    };
    let centralMass = parseFloat($('mCentral').value)*MSUN;

    function link(rangeId, numId, cb){ const r=$(rangeId), n=$(numId); function sync(fr){ if(fr) n.value=r.value; else r.value=n.value; cb(parseFloat(r.value)); } r.addEventListener('input',()=>sync(true)); n.addEventListener('input',()=>sync(false)); sync(true); }
    link('nStars','nStarsNum', v=>state.n=v|0);
    link('radiusAU','radiusAUNum', v=>state.radiusAU=v);
    link('initV','initVNum', v=>state.initV_kms=v);
    link('mMin','mMinNum', v=>state.mMinMSun=v);
    link('mMax','mMaxNum', v=>state.mMaxMSun=v);
    link('softening','softeningNum', v=>state.softening=v);
    $('collisionMode').addEventListener('change', e=>state.collisionMode=e.target.value);
    $('trailPreset').addEventListener('change', e=>{ const map={none:0,short:6,long:20,ultra:45}; const v=map[e.target.value]; $('trailSeconds').value=v; $('trailSecondsNum').value=v; state.trailSeconds=v; });
    $('glowMode').addEventListener('change', e=>{ state.glow = e.target.value==='on'; });
    $('glowIntensity').addEventListener('input', e=>{ state.glowIntensity=parseFloat(e.target.value); });
    link('mCentral','mCentralNum', v=>{ centralMass=v*MSUN; updateCentral(); });
    $('btnStart').onclick=()=>state.running=true;
    $('btnPause').onclick=()=>state.running=false;
    $('btnReset').onclick=()=>resetSystem();
    $('btnAutoFit').onclick=()=>autoFit();
    $('btnClear').onclick=()=>clearTrails();

    const scene=new THREE.Scene(); scene.background=new THREE.Color(0x0b0f16);
    const vpEl=$('viewport');
    const camera=new THREE.PerspectiveCamera(55,1,0.01,5000); camera.position.set(12,10,18);
    const renderer=new THREE.WebGLRenderer({antialias:true}); vpEl.appendChild(renderer.domElement);
    const controls=new THREE.TrackballControls(camera, renderer.domElement);
    controls.rotateSpeed=3; controls.zoomSpeed=1.2; controls.panSpeed=0.8; controls.staticMoving=true; controls.dynamicDampingFactor=0.2;

    const trailCanvas=$('trailCanvas'); const trailCtx=trailCanvas.getContext('2d');
    const chartCanvas=$('chart'); const chartCtx=chartCanvas.getContext('2d'); let chartData=[]; const chartMaxPoints=600;

    function resizeAll(){ const w=vpEl.clientWidth||1, h=vpEl.clientHeight||1; renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix(); trailCanvas.width=w; trailCanvas.height=h; const dpr=Math.min(devicePixelRatio,2); const chartW=520, chartH=140; chartCanvas.width=chartW*dpr; chartCanvas.height=chartH*dpr; chartCanvas.style.width=chartW+'px'; chartCanvas.style.height=chartH+'px'; }
    window.addEventListener('resize', resizeAll); resizeAll();

    (function(){ const geo=new THREE.BufferGeometry(); const N=1000, arr=new Float32Array(N*3); for(let i=0;i<N;i++){ const r=1200,t=Math.random()*Math.PI*2,p=Math.acos(2*Math.random()-1); arr[3*i]=r*Math.sin(p)*Math.cos(t); arr[3*i+1]=r*Math.sin(p)*Math.sin(t); arr[3*i+2]=r*Math.cos(p);} geo.setAttribute('position',new THREE.BufferAttribute(arr,3)); const mat=new THREE.PointsMaterial({size:1.5,color:0x6fa3ff}); scene.add(new THREE.Points(geo,mat)); })();

    function centralRadiusAU(mkg){ const RSun=6.9634e8; const r=RSun*Math.pow(mkg/MSUN,0.8); return (r/AU)*20; }
    const cMat=new THREE.MeshBasicMaterial({color:0xffd27a});
    let central=new THREE.Mesh(new THREE.SphereGeometry(centralRadiusAU(centralMass), 24, 18), cMat); scene.add(central);
    function makeGlowSprite(size){ const c=document.createElement('canvas'); c.width=c.height=256; const ctx=c.getContext('2d'); const g=ctx.createRadialGradient(128,128,0,128,128,128); g.addColorStop(0,'rgba(255,220,180,1)'); g.addColorStop(1,'rgba(255,220,180,0)'); ctx.fillStyle=g; ctx.fillRect(0,0,256,256); const tex=new THREE.CanvasTexture(c); const mat=new THREE.SpriteMaterial({map:tex, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, opacity: state.glow?state.glowIntensity:0}); const spr=new THREE.Sprite(mat); spr.scale.set(size,size,1); return spr; }
    let centralHalo=makeGlowSprite(10); scene.add(centralHalo);
    function updateCentral(){ const r=centralRadiusAU(centralMass); central.geometry.dispose(); central.geometry=new THREE.SphereGeometry(r,24,18); centralHalo.material.opacity = state.glow?state.glowIntensity:0; centralHalo.scale.setScalar(1+8*state.glowIntensity); }

    function starRadiusFromMass(mkg){ const RSun=6.9634e8; const r=RSun*Math.pow(mkg/MSUN,0.8); return (r/AU)*12; }
    function massToHex(mSun){ const t=Math.max(0,Math.min(1,(Math.log10(mSun+1e-6)+6)/6)); const r=255,g=Math.floor(180+60*t),b=Math.floor(120+135*(1-t)); return (r<<16)|(g<<8)|b; }
    let bodies=[];

    function resetSystem(){ for(const b of bodies) scene.remove(b.mesh); bodies.length=0; chartData.length=0; clearTrails(); updateCentral(); const R=state.radiusAU*AU;
      for(let i=0;i<state.n;i++){ let x,y,z; do{ x=(Math.random()*2-1)*R; y=(Math.random()*2-1)*R; z=(Math.random()*2-1)*R; }while(x*x+y*y+z*z>R*R);
        const pos=new THREE.Vector3(x,y,z); const m=THREE.MathUtils.lerp(state.mMinMSun,state.mMaxMSun,Math.random())*MSUN; const r=Math.max(starRadiusFromMass(m),0.002*AU);
        const mesh=new THREE.Mesh(new THREE.SphereGeometry(r,12,8), new THREE.MeshBasicMaterial({color:massToHex(m/MSUN)}));
        mesh.position.copy(pos.clone().divideScalar(AU)); scene.add(mesh);
        let vel=new THREE.Vector3(); const v0=state.initV_kms*1000; if(v0!==0){ const nrm=pos.clone().normalize(); let a=new THREE.Vector3(nrm.y,-nrm.x,0).normalize(); vel=a.multiplyScalar(v0); }
        bodies.push({pos,vel,mass:m,radius:r,mesh});
      } autoFit(); }

    function autoFit(){ const dist=Math.max(8,state.radiusAU*3); camera.position.set(dist,dist*0.8,dist*1.2); controls.target.set(0,0,0); controls.update(); }
    function clearTrails(){ trailCtx.clearRect(0,0,trailCanvas.width, trailCanvas.height); }

    function handleElastic(a,b){ const n=b.pos.clone().sub(a.pos).normalize(); const va=a.vel.dot(n), vb=b.vel.dot(n); const ma=a.mass, mb=b.mass; const va2=(va*(ma-mb)+2*mb*vb)/(ma+mb); const vb2=(vb*(mb-ma)+2*ma*va)/(ma+mb); a.vel.addScaledVector(n,va2-va); b.vel.addScaledVector(n,vb2-vb); }
    function handleMerge(i,j){ const a=bodies[i], b=bodies[j]; const m=a.mass+b.mass; const v=a.vel.clone().multiplyScalar(a.mass).add(b.vel.clone().multiplyScalar(b.mass)).divideScalar(m); const pos=a.pos.clone().add(b.pos).multiplyScalar(0.5); a.mass=m; a.vel=v; a.pos=pos; a.radius=starRadiusFromMass(m); a.mesh.geometry.dispose(); a.mesh.geometry=new THREE.SphereGeometry(a.radius,12,8); a.mesh.material.color.setHex(massToHex(m/MSUN)); scene.remove(b.mesh); bodies.splice(j,1); }

    function stepPhysics(h){ const eps2=(state.softening*AU)**2; for(let i=0;i<bodies.length;i++){ const b=bodies[i]; const r=b.pos.length(); const aMag=-G*centralMass/(r*r+eps2); const nrm=r>0? b.pos.clone().divideScalar(r): new THREE.Vector3(); b.vel.addScaledVector(nrm,aMag*h); b.pos.addScaledVector(b.vel,h); const cR=central.geometry.parameters.radius*AU; if(r<cR){ const normal=b.pos.clone().normalize(); const vn=normal.multiplyScalar(b.vel.dot(normal)); const vt=b.vel.clone().sub(vn); b.vel.copy(vt.sub(vn)); b.pos.copy(normal.multiplyScalar(cR*1.01)); } b.mesh.position.copy(b.pos.clone().divideScalar(AU)); }
      if(state.collisionMode!=='none'){ for(let i=0;i<bodies.length;i++) for(let j=i+1;j<bodies.length;j++){ const bi=bodies[i], bj=bodies[j]; const d=bi.pos.distanceTo(bj.pos); if(d<bi.radius + bj.radius){ if(state.collisionMode==='elastic') handleElastic(bi,bj); else if(state.collisionMode==='merge'){ handleMerge(i,j); j--; } } } } }

    function sampleEnergy(){ let K=0,U=0; const eps2=(state.softening*AU)**2; for(const b of bodies){ K += 0.5*b.mass*b.vel.lengthSq(); const r=b.pos.length(); U += -G*centralMass*b.mass/Math.sqrt(r*r+eps2); } chartData.push({K,U,T:K+U}); if(chartData.length>chartMaxPoints) chartData.shift(); }
    function drawChart(){ const dpr=Math.min(devicePixelRatio,2); const w=chartCanvas.width, h=chartCanvas.height; chartCtx.clearRect(0,0,w,h); if(chartData.length<2) return; const K=chartData.map(d=>d.K), U=chartData.map(d=>d.U), T=chartData.map(d=>d.T); const minY=Math.min(...K,...U,...T), maxY=Math.max(...K,...U,...T); const pad=10*dpr; const xStep=(w-2*pad)/(chartData.length-1); const mapY=v=> h - pad - (v-minY)/(maxY-minY+1e-9)*(h-2*pad); function series(a,c){ chartCtx.beginPath(); chartCtx.lineWidth=2*dpr; chartCtx.strokeStyle=c; chartCtx.moveTo(pad,mapY(a[0])); for(let i=1;i<a.length;i++) chartCtx.lineTo(pad+i*xStep,mapY(a[i])); chartCtx.stroke(); } series(K,'#6fc2ff'); series(U,'#f6d06f'); series(T,'#a9f56f'); }

    function renderTrails(dt){ const w=trailCanvas.width,h=trailCanvas.height; if(state.trailSeconds<=0){ trailCtx.clearRect(0,0,w,h); return; } const decay=Math.max(0,1 - dt*(1/state.trailSeconds)); trailCtx.globalCompositeOperation='source-over'; trailCtx.fillStyle='rgba(13,19,34,'+(1-decay)+')'; trailCtx.fillRect(0,0,w,h); trailCtx.globalCompositeOperation='lighter'; const v3=new THREE.Vector3(); for(const b of bodies){ v3.copy(b.mesh.position).project(camera); const x=(v3.x*0.5+0.5)*w; const y=(-v3.y*0.5+0.5)*h; trailCtx.fillStyle='rgba(180,200,255,'+(0.4+0.6*state.glowIntensity)+')'; trailCtx.fillRect(x,y,1.5,1.5); } }

    function updateMetrics(){ const n=bodies.length; const avgR = n? bodies.reduce((s,b)=>s+b.pos.length(),0)/n : 0; const avgV = n? bodies.reduce((s,b)=>s+b.vel.length(),0)/n : 0; $('metrics').textContent=[ 'Version: v2.0.3', 'Renderer: '+(renderer.capabilities.isWebGL2?'WebGL2':'WebGL1'), 'Bodies: '+n, 'Central Mass: '+(centralMass/MSUN).toFixed(3)+' M\u2609', 'Avg radius: '+(avgR/AU).toFixed(3)+' AU', 'Avg speed: '+(avgV/1000).toFixed(3)+' km/s', 'Collision: '+state.collisionMode, 'Softening ε: '+state.softening.toFixed(3), 'Glow: '+(state.glow?('On ('+state.glowIntensity.toFixed(2)+')'):'Off') ].join('\n'); }

    resetSystem(); autoFit();
    let last=performance.now();
    function loop(){ requestAnimationFrame(loop); const now=performance.now(); const dt=Math.max(0,(now-last)/1000); last=now; if(state.running){ const sim=dt*state.timeScale; const steps=Math.max(1,Math.ceil(sim/state.subDt)); const h=sim/steps; for(let s=0;s<steps;s++) stepPhysics(h); sampleEnergy(); } controls.update(); renderer.render(scene,camera); renderTrails(dt); drawChart(); updateMetrics(); centralHalo.position.set(0,0,0); centralHalo.material.opacity = state.glow?state.glowIntensity:0; }
    loop();

    setStatus('✅ Ready — hit Start');
  }
})();
</script>
</body>
</html>
