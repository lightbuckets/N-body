
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>N-Body 3D with Trails and Glow</title>
<style>
html,body { margin:0; padding:0; height:100%; background:#000; color:#0f0; font-family: monospace; }
#canvas { display:block; width:100%; height:100%; background:#000; }
#diag { position:fixed; top:0; left:0; padding:8px; background:rgba(0,0,0,0.7); font-size:12px; color:#0f0; white-space:pre; max-height:200px; overflow:auto; }
#controls { position:fixed; top:0; right:0; background:rgba(0,0,0,0.7); padding:8px; color:#fff; font-size:14px; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="diag">Bootingâ€¦</div>
<div id="controls">
<label><input type="checkbox" id="showTrails" checked> Show Trails</label><br>
<label><input type="range" id="glowStrength" min="0" max="1" step="0.05" value="0.5"> Glow Strength</label>
</div>
<script>
const diag = document.getElementById('diag');
function log(msg){ diag.textContent += "\n" + msg; diag.scrollTop = diag.scrollHeight; }

let gl, program, glowProgram;
let pointBuffer, numPoints = 500;
let positions = new Float32Array(numPoints*3);
let velocities = new Float32Array(numPoints*3);
let masses = new Float32Array(numPoints);
let showTrails = true;
let glowStrength = 0.5;
let trailFramebuffer, trailTexture;

document.getElementById('showTrails').addEventListener('change', e => {
    showTrails = e.target.checked;
});
document.getElementById('glowStrength').addEventListener('input', e => {
    glowStrength = parseFloat(e.target.value);
});

function initGL(){
    const canvas = document.getElementById('canvas');
    gl = canvas.getContext('webgl');
    if(!gl){ log("WebGL not supported."); return; }
    log("WebGL OK: " + gl.getParameter(gl.VERSION));
    resize();
    window.addEventListener('resize', resize);
    initParticles();
    initPrograms();
    initTrails();
    requestAnimationFrame(loop);
}

function resize(){
    const canvas = document.getElementById('canvas');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    if(gl){
        gl.viewport(0, 0, canvas.width, canvas.height);
    }
}

function initParticles(){
    for(let i=0; i<numPoints; i++){
        positions[i*3] = (Math.random()*2 - 1) * 0.5;
        positions[i*3+1] = (Math.random()*2 - 1) * 0.5;
        positions[i*3+2] = (Math.random()*2 - 1) * 0.5;
        velocities[i*3] = (Math.random()*2 - 1) * 0.001;
        velocities[i*3+1] = (Math.random()*2 - 1) * 0.001;
        velocities[i*3+2] = (Math.random()*2 - 1) * 0.001;
        masses[i] = 1.0;
    }
}

function initPrograms(){
    const vsSource = \`
    attribute vec3 aPosition;
    void main(void){
        gl_PointSize = 4.0;
        gl_Position = vec4(aPosition, 1.0);
    }\`;
    const fsSource = \`
    precision mediump float;
    uniform float uGlow;
    void main(void){
        float dist = length(gl_PointCoord - vec2(0.5));
        float alpha = smoothstep(0.5, 0.0, dist) * uGlow + 0.5*(1.0-uGlow);
        gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
    }\`;
    const vs = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vs, vsSource);
    gl.compileShader(vs);
    const fs = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fs, fsSource);
    gl.compileShader(fs);
    program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    program.aPosition = gl.getAttribLocation(program, "aPosition");
    program.uGlow = gl.getUniformLocation(program, "uGlow");

    pointBuffer = gl.createBuffer();
}

function initTrails(){
    trailFramebuffer = gl.createFramebuffer();
    trailTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, trailTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.canvas.width, gl.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.bindFramebuffer(gl.FRAMEBUFFER, trailFramebuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, trailTexture, 0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}

function updatePhysics(dt){
    const G = 0.0001;
    for(let i=0; i<numPoints; i++){
        for(let j=i+1; j<numPoints; j++){
            let dx = positions[j*3] - positions[i*3];
            let dy = positions[j*3+1] - positions[i*3+1];
            let dz = positions[j*3+2] - positions[i*3+2];
            let distSqr = dx*dx + dy*dy + dz*dz + 0.0001;
            let invDist = 1.0 / Math.sqrt(distSqr);
            let force = G * masses[i] * masses[j] * invDist * invDist;
            let fx = force * dx * invDist;
            let fy = force * dy * invDist;
            let fz = force * dz * invDist;
            velocities[i*3] += fx / masses[i] * dt;
            velocities[i*3+1] += fy / masses[i] * dt;
            velocities[i*3+2] += fz / masses[i] * dt;
            velocities[j*3] -= fx / masses[j] * dt;
            velocities[j*3+1] -= fy / masses[j] * dt;
            velocities[j*3+2] -= fz / masses[j] * dt;
        }
    }
    for(let i=0; i<numPoints; i++){
        positions[i*3] += velocities[i*3] * dt;
        positions[i*3+1] += velocities[i*3+1] * dt;
        positions[i*3+2] += velocities[i*3+2] * dt;
    }
}

function loop(){
    updatePhysics(1.0);
    if(showTrails){
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.clearColor(0.0,0.0,0.0,0.05);
    } else {
        gl.clearColor(0.0,0.0,0.0,1.0);
    }
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(program);
    gl.uniform1f(program.uGlow, glowStrength);
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STREAM_DRAW);
    gl.enableVertexAttribArray(program.aPosition);
    gl.vertexAttribPointer(program.aPosition, 3, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.POINTS, 0, numPoints);
    requestAnimationFrame(loop);
}

initGL();
</script>
</body>
</html>
