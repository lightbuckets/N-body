<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>N-Body Playground by Steve Cullen and ChatGPT (v2.0.1)</title>
<style>
  html, body { margin:0; height:100%; background:#0b0f16; color:#e6eef8; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
  #topbar { position:fixed; top:0; left:0; right:0; display:flex; align-items:center; gap:16px; padding:10px 12px; background:#0d1628; border-bottom:1px solid #1a2b4a; z-index:20; }
  #title { font-weight:700; letter-spacing:.3px; }
  #status { font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space:pre; opacity:.9; }
  #app { position:fixed; inset:46px 0 0 0; display:grid; grid-template-columns:320px 1fr 360px; }
  #left, #right { background:#0e1320; border-right:1px solid #1a2235; overflow:auto; }
  #right { border-left:1px solid #1a2235; border-right:none; }
  #viewport { position:relative; }
  .panel { padding:12px; }
  h2 { margin:8px 0 6px; font-size:16px; letter-spacing:.3px; color:#b9d2ff }
  .group { margin:8px 0 14px; padding:10px; background:#0b1120; border:1px solid #1a2235; border-radius:8px; }
  .row { display:grid; grid-template-columns: 1fr 100px; gap:8px; align-items:center; margin:6px 0; }
  .row label { font-size:13px; color:#cfe0ff; }
  .row input[type="range"] { width:100%; }
  .row input[type="number"], .row select { width:100%; padding:6px; background:#0f1526; border:1px solid #28365a; color:#e6eef8; border-radius:6px; }
  .buttons { display:flex; gap:8px; flex-wrap:wrap; }
  button { padding:8px 10px; border-radius:8px; border:1px solid #33466f; background:#13203a; color:#e6eef8; cursor:pointer; }
  button.primary { border-color:#4a83ff; background:#1a2f5c; }
  .hint { font-size:12px; color:#9fb4db; margin-top:6px; }
  #chartWrap { position:absolute; left:12px; bottom:12px; width:520px; background:#0d1322c0; border:1px solid #1a2235; border-radius:8px; padding:8px; backdrop-filter: blur(4px); }
  #chart { width:100%; height:140px; display:block; background:#0c111d; border-radius:6px; }
  #legend { display:flex; gap:12px; font-size:12px; margin:6px 2px 0; color:#c9d8f4; opacity:.9; }
  #legend span::before { content:""; display:inline-block; width:10px; height:10px; margin-right:6px; border-radius:2px; vertical-align:baseline; }
  #legK::before { background:#6fc2ff; }
  #legU::before { background:#f6d06f; }
  #legT::before { background:#a9f56f; }
  #metrics { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; line-height:1.35; white-space:pre-wrap; }
  canvas { display:block; }
  #trailCanvas { position:absolute; inset:0; pointer-events:none; }
</style>
</head>
<body>
<div id="topbar">
  <div id="title">N-Body Playground by Steve Cullen and ChatGPT (v2.0.1)</div>
  <div id="status">Booting…</div>
</div>

<div id="app">
  <div id="left" class="panel">
    <h2>Setup</h2>
    <div class="group">
      <div class="row"><label>Stars (N)</label><input id="nStars" type="range" min="50" max="3000" step="50" value="800"><input id="nStarsNum" type="number" min="50" max="3000" step="50" value="800"></div>
      <div class="row"><label>Init radius (AU)</label><input id="radiusAU" type="range" min="0.2" max="50" step="0.1" value="6"><input id="radiusAUNum" type="number" min="0.2" max="50" step="0.1" value="6"></div>
      <div class="row"><label>Init velocity (km/s)</label><input id="initV" type="range" min="0" max="80" step="1" value="0"><input id="initVNum" type="number" min="0" max="80" step="1" value="0"></div>
      <div class="row"><label>Star mass min (M☉)</label><input id="mMin" type="range" min="1e-6" max="1" step="1e-6" value="5e-5"><input id="mMinNum" type="number" step="1e-6" value="5e-5"></div>
      <div class="row"><label>Star mass max (M☉)</label><input id="mMax" type="range" min="1e-6" max="5" step="1e-6" value="1e-3"><input id="mMaxNum" type="number" step="1e-6" value="1e-3"></div>
    </div>

    <h2>Central Star</h2>
    <div class="group">
      <div class="row"><label>Mass (M☉)</label><input id="mCentral" type="range" min="0.1" max="50" step="0.1" value="1"><input id="mCentralNum" type="number" min="0.1" max="50" step="0.1" value="1"></div>
      <div class="row"><label>Glow</label>
        <select id="glowMode">
          <option value="off">Off</option>
          <option value="on" selected>On</option>
        </select>
        <input id="glowIntensity" type="range" min="0" max="1" step="0.01" value="0.6">
      </div>
    </div>

    <h2>Collisions</h2>
    <div class="group">
      <div class="row"><label>Collision mode</label>
        <select id="collisionMode">
          <option value="none" selected>None</option>
          <option value="elastic">Elastic</option>
          <option value="merge">Merge</option>
        </select>
      </div>
      <div class="row"><label>Softening (ε)</label><input id="softening" type="range" min="0" max="0.2" step="0.001" value="0.01"><input id="softeningNum" type="number" min="0" max="0.2" step="0.001" value="0.01"></div>
    </div>

    <h2>Trails</h2>
    <div class="group">
      <div class="row"><label>Preset</label>
        <select id="trailPreset">
          <option value="none">None</option>
          <option value="short">Short</option>
          <option value="long" selected>Long</option>
          <option value="ultra">Ultra</option>
        </select>
      </div>
      <div class="row"><label>Persistence (s)</label><input id="trailSeconds" type="range" min="0" max="60" step="1" value="20"><input id="trailSecondsNum" type="number" min="0" max="60" step="1" value="20"></div>
    </div>

    <div class="buttons">
      <button id="btnReset">Reset</button>
      <button id="btnStart" class="primary">Start</button>
      <button id="btnPause">Pause</button>
      <button id="btnClear">Clear Trails</button>
      <button id="btnAutoFit">Auto Fit</button>
    </div>

    <div class="hint">Trackball: drag=rotate, right‑drag=pan, wheel=zoom.</div>
  </div>

  <div id="viewport">
    <canvas id="trailCanvas"></canvas>
    <div id="chartWrap">
      <canvas id="chart"></canvas>
      <div id="legend"><span id="legK">Kinetic</span><span id="legU">Potential</span><span id="legT">Total</span></div>
    </div>
  </div>

  <div id="right" class="panel">
    <h2>Metrics</h2>
    <div class="group"><div id="metrics">—</div></div>
  </div>
</div>

<script src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.150.1/examples/js/controls/TrackballControls.js"></script>
<script>
(function() {{
  const statusEl = document.getElementById('status');
  function webglInfo() {{
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl) return {{ ok:false, msg:'WebGL not supported' }};
    let vendor='n/a', renderer='n/a', version=gl.getParameter(gl.VERSION);
    const dbg = gl.getExtension('WEBGL_debug_renderer_info');
    try {{
      if (dbg) {{
        vendor = gl.getParameter(dbg.UNMASKED_VENDOR_WEBGL);
        renderer = gl.getParameter(dbg.UNMASKED_RENDERER_WEBGL);
      }} else {{
        vendor = gl.getParameter(gl.VENDOR);
        renderer = gl.getParameter(gl.RENDERER);
      }}
    }} catch(e) {{}}
    return {{ ok:true, vendor, renderer, version }};
  }}
  const boot = webglInfo();
  statusEl.textContent = boot.ok
    ? `WebGL OK | Vendor: ${{boot.vendor}} | GPU: ${{boot.renderer}}`
    : `WebGL FAILED: ${{boot.msg}}`;
}})();
</script>

<script>
(function() {{
  const AU = 1.496e11, MSUN = 1.989e30, G = 6.67430e-11;

  const state = {{
    n: 800,
    radiusAU: 6,
    initV_kms: 0,
    mMinMSun: 5e-5,
    mMaxMSun: 1e-3,
    softening: 0.01,
    collisionMode: 'none',
    trailSeconds: 20,
    glow: true,
    glowIntensity: 0.6,
    running: false,
    timeScale: 1500,
    subDt: 0.02
  }};

  let centralMass = 1 * MSUN;

  const chartCanvas = document.getElementById('chart');
  const chartCtx = chartCanvas.getContext('2d');
  let chartData = [];
  const chartMaxPoints = 600;

  const trailCanvas = document.getElementById('trailCanvas');
  const trailCtx = trailCanvas.getContext('2d');

  const $ = (id)=>document.getElementById(id);
  function link(rangeId, numId, cb) {{
    const r=$(rangeId), n=$(numId);
    function sync(fromRange) {{ if (fromRange) n.value=r.value; else r.value=n.value; cb(parseFloat(r.value)); }}
    r.addEventListener('input', ()=>sync(true)); n.addEventListener('input', ()=>sync(false)); sync(true);
  }}
  link('nStars','nStarsNum', v=>state.n=v|0);
  link('radiusAU','radiusAUNum', v=>state.radiusAU=v);
  link('initV','initVNum', v=>state.initV_kms=v);
  link('mMin','mMinNum', v=>state.mMinMSun=v);
  link('mMax','mMaxNum', v=>state.mMaxMSun=v);
  link('softening','softeningNum', v=>state.softening=v);
  $('collisionMode').addEventListener('change', e=>state.collisionMode=e.target.value);
  $('trailPreset').addEventListener('change', e=>{{ const map={{none:0,short:6,long:20,ultra:45}}; const v=map[e.target.value]; $('trailSeconds').value=v; $('trailSecondsNum').value=v; state.trailSeconds=v; }});
  $('glowMode').addEventListener('change', e=>{{ state.glow = e.target.value==='on'; }});
  $('glowIntensity').addEventListener('input', e=>{{ state.glowIntensity = parseFloat(e.target.value); }});
  link('mCentral','mCentralNum', v=>{{ centralMass = v*MSUN; updateCentral(); }});
  $('btnStart').onclick = ()=> state.running = true;
  $('btnPause').onclick = ()=> state.running = false;
  $('btnReset').onclick = ()=> resetSystem();
  $('btnAutoFit').onclick = ()=> autoFit();
  $('btnClear').onclick = ()=> clearTrails();

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0f16);
  const vpEl = document.getElementById('viewport');
  const camera = new THREE.PerspectiveCamera(55, 1, 0.01, 5000);
  camera.position.set(12, 10, 18);
  const renderer = new THREE.WebGLRenderer({ antialias:true });
  vpEl.appendChild(renderer.domElement);
  const controls = new THREE.TrackballControls(camera, renderer.domElement);
  controls.rotateSpeed = 3; controls.zoomSpeed=1.2; controls.panSpeed=0.8; controls.staticMoving=true; controls.dynamicDampingFactor=0.2;

  function resizeAll() {{
    const w = vpEl.clientWidth||1, h = vpEl.clientHeight||1;
    renderer.setSize(w,h,false);
    camera.aspect = w/h; camera.updateProjectionMatrix();
    trailCanvas.width = w; trailCanvas.height = h;
    const dpr = Math.min(devicePixelRatio,2);
    const chartW = 520, chartH = 140;
    chartCanvas.width = chartW*dpr; chartCanvas.height = chartH*dpr;
    chartCanvas.style.width = chartW+'px'; chartCanvas.style.height = chartH+'px';
  }}
  window.addEventListener('resize', resizeAll); resizeAll();

  (function addStarfield(){{
    const geo = new THREE.BufferGeometry();
    const N = 1000, arr = new Float32Array(N*3);
    for (let i=0;i<N;i++){{ const r=1200, t=Math.random()*Math.PI*2, p=Math.acos(2*Math.random()-1); arr[3*i]=r*Math.sin(p)*Math.cos(t); arr[3*i+1]=r*Math.sin(p)*Math.sin(t); arr[3*i+2]=r*Math.cos(p);}}
    geo.setAttribute('position', new THREE.BufferAttribute(arr,3));
    const mat = new THREE.PointsMaterial({ size:1.5, color:0x6fa3ff });
    scene.add(new THREE.Points(geo,mat));
  }})();

  let central, centralHalo;
  function centralRadiusAU(mkg) {{ const RSun=6.9634e8; const r=RSun*Math.pow(mkg/MSUN,0.8); return (r/AU)*20; }}
  function updateCentral() {{
    const rAU = centralRadiusAU(centralMass);
    central.geometry.dispose(); central.geometry = new THREE.SphereGeometry(rAU, 24, 18);
    if (centralHalo) centralHalo.scale.setScalar(1 + 8*state.glowIntensity);
    central.material.opacity = 1.0;
  }}
  function addGlowSprite(size) {{
    const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
    const ctx = canvas.getContext('2d');
    const grd = ctx.createRadialGradient(128,128,0,128,128,128);
    grd.addColorStop(0, 'rgba(255,220,180,1)');
    grd.addColorStop(1, 'rgba(255,220,180,0)');
    ctx.fillStyle = grd; ctx.fillRect(0,0,256,256);
    const tex = new THREE.CanvasTexture(canvas); tex.minFilter = THREE.LinearFilter; tex.magFilter = THREE.LinearFilter; tex.wrapS=tex.wrapT=THREE.ClampToEdgeWrapping;
    const mat = new THREE.SpriteMaterial({ map: tex, color: 0xffffff, opacity: 0.6, depthWrite:false, transparent:true, blending: THREE.AdditiveBlending });
    const sprite = new THREE.Sprite(mat); sprite.scale.set(size,size,1);
    return sprite;
  }}

  const cMat = new THREE.MeshBasicMaterial({ color:0xffd27a });
  central = new THREE.Mesh(new THREE.SphereGeometry(centralRadiusAU(centralMass), 24, 18), cMat);
  scene.add(central);
  centralHalo = addGlowSprite(10);
  scene.add(centralHalo);

  let bodies = [];
  function starRadiusFromMass(mkg) {{ const RSun=6.9634e8; const r=RSun*Math.pow(mkg/MSUN,0.8); return (r/AU)*12; }}
  function massToColorHex(mSun) {{ const t = Math.max(0, Math.min(1, (Math.log10(mSun+1e-6)+6)/6 )); const r=255, g=Math.floor(180+60*t), b=Math.floor(120+135*(1-t)); return (r<<16)|(g<<8)|b; }}

  function resetSystem() {{
    for (const b of bodies) {{ scene.remove(b.mesh); if (b.halo) scene.remove(b.halo); }}
    bodies.length=0; chartData.length=0; clearTrails();
    updateCentral();
    const R = state.radiusAU * AU;
    for (let i=0;i<state.n;i++) {{
      let x,y,z; do {{ x=(Math.random()*2-1)*R; y=(Math.random()*2-1)*R; z=(Math.random()*2-1)*R; }} while (x*x+y*y+z*z>R*R);
      const pos = new THREE.Vector3(x,y,z);
      const m = THREE.MathUtils.lerp(state.mMinMSun, state.mMaxMSun, Math.random()) * MSUN;
      const r = Math.max(starRadiusFromMass(m), 0.002*AU);
      const color = massToColorHex(m/MSUN);
      const mesh = new THREE.Mesh(new THREE.SphereGeometry(r, 12, 8), new THREE.MeshBasicMaterial({ color }));
      mesh.position.copy(pos.clone().divideScalar(AU)); scene.add(mesh);
      let vel = new THREE.Vector3();
      const v0 = state.initV_kms*1000;
      if (v0!==0) {{ const nrm = pos.clone().normalize(); let a = new THREE.Vector3(nrm.y, -nrm.x, 0).normalize(); vel = a.multiplyScalar(v0); }}
      let halo = null;
      if (state.glow) {{ halo = addGlowSprite(r*6/AU); halo.material.opacity = state.glowIntensity; halo.position.copy(mesh.position); scene.add(halo); }}
      bodies.push({ pos, vel, mass:m, radius:r, mesh, halo });
    }}
    autoFit();
  }}

  function autoFit() {{ const dist = Math.max(8, state.radiusAU*3); camera.position.set(dist, dist*0.8, dist*1.2); controls.target.set(0,0,0); controls.update(); }}

  function clearTrails() {{ trailCtx.clearRect(0,0,trailCanvas.width, trailCanvas.height); }}

  function handleElastic(a,b) {{
    const n = b.pos.clone().sub(a.pos).normalize();
    const va = a.vel.dot(n), vb = b.vel.dot(n);
    const ma=a.mass, mb=b.mass;
    const va2 = (va*(ma-mb)+2*mb*vb)/(ma+mb);
    const vb2 = (vb*(mb-ma)+2*ma*va)/(ma+mb);
    a.vel.addScaledVector(n, va2-va); b.vel.addScaledVector(n, vb2-vb);
  }}
  function handleMerge(i,j) {{
    const a=bodies[i], b=bodies[j];
    const m=a.mass+b.mass;
    const v=a.vel.clone().multiplyScalar(a.mass).add(b.vel.clone().multiplyScalar(b.mass)).divideScalar(m);
    const pos=a.pos.clone().add(b.pos).multiplyScalar(0.5);
    a.mass=m; a.vel=v; a.pos=pos; a.radius = starRadiusFromMass(m);
    a.mesh.geometry.dispose(); a.mesh.geometry = new THREE.SphereGeometry(a.radius,12,8);
    a.mesh.material.color.setHex(massToColorHex(m/MSUN));
    scene.remove(b.mesh); if (b.halo) scene.remove(b.halo);
    bodies.splice(j,1);
  }}

  function stepPhysics(h) {{
    const eps2 = (state.softening*AU)**2;
    for (let i=0;i<bodies.length;i++) {{
      const b = bodies[i];
      const r = b.pos.length();
      const aMag = - G * centralMass / (r*r + eps2);
      const nrm = r>0 ? b.pos.clone().divideScalar(r) : new THREE.Vector3();
      b.vel.addScaledVector(nrm, aMag*h);
      b.pos.addScaledVector(b.vel, h);
      const cR = central.geometry.parameters.radius * AU;
      if (r<cR) {{ const normal = b.pos.clone().normalize(); const vn = normal.multiplyScalar(b.vel.dot(normal)); const vt = b.vel.clone().sub(vn); b.vel.copy(vt.sub(vn)); b.pos.copy(normal.multiplyScalar(cR*1.01)); }}
      const pAU = b.pos.clone().divideScalar(AU);
      b.mesh.position.copy(pAU);
      if (b.halo) b.halo.position.copy(pAU);
    }}
    if (state.collisionMode!=='none') {{
      for (let i=0;i<bodies.length;i++) for (let j=i+1;j<bodies.length;j++) {{
        const bi=bodies[i], bj=bodies[j];
        const d = bi.pos.distanceTo(bj.pos);
        if (d < bi.radius + bj.radius) {{
          if (state.collisionMode==='elastic') handleElastic(bi,bj);
          else if (state.collisionMode==='merge') {{ handleMerge(i,j); j--; }}
        }}
      }}
    }}
  }}

  function sampleEnergy() {{
    let K=0, U=0; const eps2=(state.softening*AU)**2;
    for (const b of bodies) {{ K += 0.5*b.mass*b.vel.lengthSq(); const r=b.pos.length(); U += -G*centralMass*b.mass/Math.sqrt(r*r+eps2); }}
    chartData.push({ K,U,T:K+U }); if (chartData.length>chartMaxPoints) chartData.shift();
  }}

  function drawChart() {{
    const dpr=Math.min(devicePixelRatio,2); const w=chartCanvas.width, h=chartCanvas.height;
    chartCtx.clearRect(0,0,w,h); if (chartData.length<2) return;
    const K=chartData.map(d=>d.K), U=chartData.map(d=>d.U), T=chartData.map(d=>d.T);
    const minY=Math.min(...K,...U,...T), maxY=Math.max(...K,...U,...T);
    const pad=10*dpr; const xStep=(w-2*pad)/(chartData.length-1);
    const mapY=v=> h - pad - (v-minY)/(maxY-minY+1e-9)*(h-2*pad);
    function series(arr, color) {{ chartCtx.beginPath(); chartCtx.lineWidth=2*dpr; chartCtx.strokeStyle=color; chartCtx.moveTo(pad,mapY(arr[0])); for (let i=1;i<arr.length;i++) chartCtx.lineTo(pad+i*xStep,mapY(arr[i])); chartCtx.stroke(); }}
    series(K,'#6fc2ff'); series(U,'#f6d06f'); series(T,'#a9f56f');
  }}

  function renderTrails(dt) {{
    const w = trailCanvas.width, h = trailCanvas.height;
    if (state.trailSeconds<=0) {{ trailCtx.clearRect(0,0,w,h); return; }}
    const decay = Math.max(0, 1 - dt*(1/state.trailSeconds));
    trailCtx.globalCompositeOperation = 'source-over';
    trailCtx.fillStyle = 'rgba(13, 19, 34,' + (1-decay) + ')';
    trailCtx.fillRect(0,0,w,h);
    trailCtx.globalCompositeOperation = 'lighter';
    const v3 = new THREE.Vector3();
    for (const b of bodies) {{
      v3.copy(b.mesh.position).project(camera);
      const x = (v3.x * 0.5 + 0.5) * w;
      const y = (-v3.y * 0.5 + 0.5) * h;
      trailCtx.fillStyle = 'rgba(180,200,255,' + (0.4+0.6*state.glowIntensity) + ')';
      trailCtx.fillRect(x, y, 1.5, 1.5);
    }}
  }}

  function updateMetrics() {{
    const n=bodies.length;
    const avgR = n? bodies.reduce((s,b)=>s+b.pos.length(),0)/n : 0;
    const avgV = n? bodies.reduce((s,b)=>s+b.vel.length(),0)/n : 0;
    document.getElementById('metrics').textContent = [
      'Version: v2.0.1',
      'Renderer: ' + (renderer.capabilities.isWebGL2 ? 'WebGL2' : 'WebGL1'),
      'Bodies: ' + n,
      'Central Mass: ' + (centralMass/MSUN).toFixed(3) + ' M\u2609',
      'Avg radius: ' + (avgR/AU).toFixed(3) + ' AU',
      'Avg speed: ' + (avgV/1000).toFixed(3) + ' km/s',
      'Collision: ' + state.collisionMode,
      'Softening ε: ' + state.softening.toFixed(3),
      'Glow: ' + (state.glow?('On ('+state.glowIntensity.toFixed(2)+')'):'Off'),
    ].join('\n');
  }}

  let last = performance.now();
  function animate() {{
    requestAnimationFrame(animate);
    const now = performance.now(); const dt = Math.max(0,(now-last)/1000); last=now;
    if (state.running) {{
      const sim = dt*state.timeScale; const steps = Math.max(1, Math.ceil(sim/state.subDt)); const h = sim/steps;
      for (let s=0;s<steps;s++) stepPhysics(h);
      sampleEnergy();
    }}
    controls.update();
    renderer.render(scene, camera);
    renderTrails(dt);
    drawChart();
    updateMetrics();
    if (centralHalo) {{ centralHalo.position.set(0,0,0); centralHalo.material.opacity = state.glow ? state.glowIntensity : 0; }}
  }}
  animate();

  resetSystem();

}})();
</script>

</body>
</html>
