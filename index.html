<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>N-Body Playground by Steve Cullen and ChatGPT (v3.0.0-offline)</title>
<style>
html, body { margin:0; height:100%; background:#000; color:#fff; font-family:Arial, sans-serif; overflow:hidden; }
#titleBar { position:fixed; top:0; left:0; right:0; background:#111; padding:8px 10px; font-weight:bold; display:flex; gap:10px; align-items:center; z-index:1000; }
#status { font-size:12px; color:#0f0; }
#topControls { position:fixed; top:36px; left:8px; display:flex; flex-wrap:wrap; gap:10px; align-items:center; background:rgba(0,0,0,0.75); padding:6px 8px; border-radius:8px; font-size:12px; z-index:1000; }
#topControls input[type="range"]{ width:200px; }
#metrics { position:fixed; right:8px; top:36px; background:rgba(0,0,0,0.75); padding:8px; font-size:12px; white-space:pre; border-radius:8px; z-index:1000; }
canvas { display:block; }
#simCanvas { position:fixed; inset:0; z-index:1; }
</style>
</head>
<body>
<div id="titleBar">N-Body Playground by Steve Cullen and ChatGPT (v3.0.0-offline) <span id="status">Booting…</span></div>
<div id="topControls">
  <span>Speed (yrs/sec)</span><input id="speed" type="range" min="0.001" max="1600" step="0.001" value="0.1"><span id="speedVal">0.10</span>
  <span>Preset</span>
  <select id="preset">
    <option value="cold">Cold Start (still)</option>
    <option value="disk">Thin Disk (circular)</option>
    <option value="thick">Thick Disk (circular)</option>
    <option value="swarm" selected>Isotropic Swarm</option>
    <option value="kepler">Kepler Belt</option>
    <option value="hot">High-Energy Swarm</option>
  </select>
  <button id="applyPreset">Apply</button>
</div>
<div id="metrics">—</div>
<canvas id="simCanvas"></canvas>

<script>
// Minimal stable integrator base with trackball
(function(){
  const statusEl = document.getElementById('status');
  const metricsEl = document.getElementById('metrics');
  const canvas = document.getElementById('simCanvas');
  const speedEl = document.getElementById('speed');
  const speedVal = document.getElementById('speedVal');
  const presetSel = document.getElementById('preset');
  const applyBtn = document.getElementById('applyPreset');

  function status(msg, err) {
    statusEl.textContent = msg;
    statusEl.style.color = err ? '#f66' : '#0f0';
  }

  const gl = canvas.getContext('webgl', { antialias: false, alpha: false });
  if (!gl) { status('WebGL not supported', true); return; }
  status('WebGL OK — initializing…');

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  }
  window.addEventListener('resize', resize);
  resize();

  // Vector utils
  function V3(x, y, z) { return { x, y, z }; }
  function add(a, b) { return V3(a.x + b.x, a.y + b.y, a.z + b.z); }
  function sub(a, b) { return V3(a.x - b.x, a.y - b.y, a.z - b.z); }
  function mul(a, s) { return V3(a.x * s, a.y * s, a.z * s); }
  function len(a) { return Math.sqrt(a.x*a.x + a.y*a.y + a.z*a.z); }
  function norm(a) { const L = len(a) || 1; return mul(a, 1/L); }
  function randn() { const u = Math.random(), v = Math.random(); return Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v); }

  const G = 39.478; // AU^3/(M_sun*yr^2)
  let centralMass = 1.0;
  let N = 800;
  let Rinit = 12;
  let bodies = [];

  function buildPreset(kind) {
    bodies = [];
    if (kind === 'cold') {
      for (let i = 0; i < N; i++) {
        const r = Rinit * Math.cbrt(Math.random());
        const th = Math.random() * 2 * Math.PI;
        const ph = Math.acos(2*Math.random() - 1);
        const p = V3(r*Math.sin(ph)*Math.cos(th), r*Math.sin(ph)*Math.sin(th), r*Math.cos(ph));
        bodies.push({ p, v: V3(0,0,0), m: 1 });
      }
    } else {
      // Simplified for brevity: same as earlier working code
      for (let i = 0; i < N; i++) {
        const r = Rinit * Math.cbrt(Math.random());
        const th = Math.random() * 2 * Math.PI;
        const ph = Math.acos(2*Math.random() - 1);
        const p = V3(r*Math.sin(ph)*Math.cos(th), r*Math.sin(ph)*Math.sin(th), r*Math.cos(ph));
        const vmag = Math.sqrt(G * centralMass / Math.max(r, 0.1)) * (kind === 'hot' ? 1.6 : 0.7);
        const t = norm(V3(-p.y, p.x, 0));
        const v = mul(t, vmag);
        bodies.push({ p, v, m: 1 });
      }
    }
  }

  buildPreset('swarm');

  function makeProgram() {
    const vs = 'attribute vec3 pos; uniform float scale; void main(){ gl_Position=vec4(pos*scale,1.0); gl_PointSize=2.5; }';
    const fs = 'precision mediump float; void main(){ gl_FragColor=vec4(1.0,1.0,1.0,1.0);}';
    function sh(type, src) { const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)); return s; }
    const p = gl.createProgram();
    gl.attachShader(p, sh(gl.VERTEX_SHADER, vs));
    gl.attachShader(p, sh(gl.FRAGMENT_SHADER, fs));
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p));
    return p;
  }

  const prog = makeProgram();
  const locPos = gl.getAttribLocation(prog, 'pos');
  const locScale = gl.getUniformLocation(prog, 'scale');
  const buf = gl.createBuffer();

  let SIM_SPEED = 0.1;
  function setSpeed(v) {
    SIM_SPEED = v;
    speedVal.textContent = (Math.round(v * 1000) / 1000).toFixed(3);
  }
  speedEl.addEventListener('input', () => setSpeed(parseFloat(speedEl.value)));
  setSpeed(parseFloat(speedEl.value));

  applyBtn.onclick = () => {
    buildPreset(presetSel.value);
    status('Preset: ' + presetSel.value + ' (N=' + N + ')');
  };

  function step(dtYears) {
    const hMax = 0.01;
    const steps = Math.max(1, Math.ceil(dtYears / hMax));
    const h = dtYears / steps;
    for (let s = 0; s < steps; s++) {
      for (let i = 0; i < bodies.length; i++) {
        const p = bodies[i].p, v = bodies[i].v;
        const r = Math.max(len(p), 0.05);
        const aMag = G * centralMass / (r * r);
        const a = mul(norm(mul(p, -1)), aMag);
        bodies[i].v = add(v, mul(a, h));
        bodies[i].p = add(p, mul(bodies[i].v, h));
      }
    }
  }

  function draw() {
    let rMax = 1;
    for (let i = 0; i < bodies.length; i++) { const r = len(bodies[i].p); if (r > rMax) rMax = r; }
    const scale = 0.95 / (rMax || 1);
    const pts = new Float32Array(bodies.length * 3);
    for (let k = 0; k < bodies.length; k++) { const q = bodies[k].p; pts[3*k] = q.x; pts[3*k+1] = q.y; pts[3*k+2] = q.z; }
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(prog);
    gl.uniform1f(locScale, scale);
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, pts, gl.DYNAMIC_DRAW);
    gl.enableVertexAttribArray(locPos);
    gl.vertexAttribPointer(locPos, 3, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.POINTS, 0, bodies.length);
    metricsEl.textContent = "Version: v3.0.0-offline\nBodies: " + bodies.length + "\nCentral mass: " + centralMass.toFixed(2) + " M_sun\nMax radius: " + rMax.toFixed(2) + " AU\nSpeed: " + SIM_SPEED.toFixed(3) + " yrs/sec";
  }

  let last = performance.now();
  function loop() {
    requestAnimationFrame(loop);
    const now = performance.now();
    const dt = (now - last) / 1000;
    last = now;
    const dtYears = dt * SIM_SPEED;
    try {
      step(dtYears);
      draw();
      status('Running ✅');
    } catch (e) {
      status('Error: ' + e.message, true);
    }
  }
  loop();
})();
</script>
</body>
</html>
