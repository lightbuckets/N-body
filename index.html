<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>N-Body Playground by Steve Cullen and ChatGPT (v2.8.2-offline)</title>
<style>
html, body { margin:0; height:100%; background:#000; color:#fff; font-family:Arial, sans-serif; overflow:hidden; }
#titleBar { position:fixed; top:0; left:0; width:100%; background:#111; padding:8px; font-weight:bold; }
#status { font-size:12px; color:#0f0; margin-left:10px; }
#metrics { position:fixed; right:0; top:30px; background:rgba(0,0,0,0.6); padding:8px; font-size:12px; white-space:pre; }
canvas { display:block; }
</style>
</head>
<body>
<div id="titleBar">N-Body Playground by Steve Cullen and ChatGPT (v2.8.2-offline) <span id="status">Booting…</span></div>
<div id="metrics">—</div>
<canvas id="simCanvas"></canvas>

<script>
(function() {
    'use strict';
    var statusEl = document.getElementById('status');
    var metricsEl = document.getElementById('metrics');
    var canvas = document.getElementById('simCanvas');
    var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl) {
        statusEl.textContent = "WebGL not supported";
        statusEl.style.color = "red";
        return;
    } else {
        statusEl.textContent = "WebGL OK — initializing…";
        statusEl.style.color = "#0f0";
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // Simple vec utilities
    function vec3(x,y,z) { return {x:x,y:y,z:z}; }
    function add(a,b) { return vec3(a.x+b.x,a.y+b.y,a.z+b.z); }
    function sub(a,b) { return vec3(a.x-b.x,a.y-b.y,a.z-b.z); }
    function mul(a,s) { return vec3(a.x*s,a.y*s,a.z*s); }
    function len(a) { return Math.sqrt(a.x*a.x+a.y*a.y+a.z*a.z); }
    function norm(a) { var l=len(a); return l>0?mul(a,1/l):vec3(0,0,0); }

    // Initial minimal system (50 bodies around a central mass), in AU/yr units
    var stars = [];
    var N = 50;
    var G = 39.478; // AU^3 / (M_sun * yr^2)
    var centralMass = 5;
    for(var i=0;i<N;i++) {
        var r = Math.random()*5+2;
        var theta = Math.random()*2*Math.PI;
        var phi = Math.acos(2*Math.random()-1);
        var pos = vec3(r*Math.sin(phi)*Math.cos(theta),
                       r*Math.sin(phi)*Math.sin(theta),
                       r*Math.cos(phi));
        var velMag = 0.6*Math.sqrt(G*centralMass/r);
        var velDir = norm(vec3(-pos.y,pos.x,0));
        var vel = mul(velDir,velMag);
        stars.push({ m: Math.random()*0.5+0.5, p: pos, v: vel });
    }

    // Build a tiny throwaway shader program each frame (simple but robust)
    function makeProgram() {
        var vsSrc = 'attribute vec3 pos; uniform float scale; void main(){ gl_Position=vec4(pos*scale,1.0); gl_PointSize=3.0; }';
        var fsSrc = 'void main(){ gl_FragColor=vec4(1.0,1.0,1.0,1.0); }';
        function compile(type, src){
            var s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s);
            if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s));
            return s;
        }
        var vs=compile(gl.VERTEX_SHADER, vsSrc);
        var fs=compile(gl.FRAGMENT_SHADER, fsSrc);
        var p=gl.createProgram(); gl.attachShader(p,vs); gl.attachShader(p,fs); gl.linkProgram(p);
        if(!gl.getProgramParameter(p, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p));
        return p;
    }

    var prog=null, locPos=-1, locScale=null, buf=null;
    function ensureGLObjects(){
        if(!prog){ prog = makeProgram(); locPos=gl.getAttribLocation(prog,'pos'); locScale=gl.getUniformLocation(prog,'scale'); }
        if(!buf){ buf = gl.createBuffer(); }
    }

    var last=performance.now();
    function loop(){
        requestAnimationFrame(loop);
        var now=performance.now(); var dt=(now-last)/1000; last=now;
        var dtYears = dt/ (365.25*24*3600); // seconds -> years (very small, but OK for demo)

        try {
            // physics: central force only
            for(var i=0;i<stars.length;i++){
                var dir = sub(vec3(0,0,0), stars[i].p);
                var r = Math.max(len(dir), 0.05);
                var aMag = G*centralMass/(r*r);
                var a = mul(norm(dir), aMag);
                stars[i].v = add(stars[i].v, mul(a, dtYears));
            }
            for(var j=0;j<stars.length;j++){
                stars[j].p = add(stars[j].p, mul(stars[j].v, dtYears));
            }

            // render points in clip space with a scale so AU map into view
            ensureGLObjects();
            var pts = new Float32Array(stars.length*3);
            for(var k=0;k<stars.length;k++){
                pts[3*k+0] = stars[k].p.x/10; // simple scale
                pts[3*k+1] = stars[k].p.y/10;
                pts[3*k+2] = stars[k].p.z/10;
            }
            gl.viewport(0,0,canvas.width,canvas.height);
            gl.clearColor(0,0,0,1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.useProgram(prog);
            gl.uniform1f(locScale, 1.0);
            gl.bindBuffer(gl.ARRAY_BUFFER, buf);
            gl.bufferData(gl.ARRAY_BUFFER, pts, gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(locPos);
            gl.vertexAttribPointer(locPos, 3, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.POINTS, 0, stars.length);

            metricsEl.textContent = "Version: v2.8.2-offline\nBodies: "+stars.length+"\nCentral mass: "+centralMass.toFixed(2)+" M_sun";
            statusEl.textContent = "First frame rendered ✅";
            statusEl.style.color = "#0f0";
        } catch(e){
            statusEl.textContent = "Error: "+e.message;
            statusEl.style.color = "red";
        }
    }
    loop();
})();
</script>
</body>
</html>
