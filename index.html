<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>N-Body Playground by Steve Cullen and ChatGPT (v2.2.0-offline)</title>
<style>
  html, body { margin:0; height:100%; background:#0b0f16; color:#e6eef8; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
  #topbar { position:fixed; top:0; left:0; right:0; display:flex; align-items:center; gap:16px; padding:10px 12px; background:#0d1628; border-bottom:1px solid #1a2b4a; z-index:20; }
  #title { font-weight:700; letter-spacing:.3px; }
  #status { font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space:pre; opacity:.9; }
  #app { position:fixed; inset:46px 0 0 0; display:grid; grid-template-columns:320px 1fr 360px; }
  #left, #right { background:#0e1320; border-right:1px solid #1a2235; overflow:auto; }
  #right { border-left:1px solid #1a2235; border-right:none; }
  #viewport { position:relative; }
  .panel { padding:12px; }
  h2 { margin:8px 0 6px; font-size:16px; letter-spacing:.3px; color:#b9d2ff }
  .group { margin:8px 0 14px; padding:10px; background:#0b1120; border:1px solid #1a2235; border-radius:8px; }
  .row { display:grid; grid-template-columns: 1fr 100px; gap:8px; align-items:center; margin:6px 0; }
  .row label { font-size:13px; color:#cfe0ff; }
  .row input[type="range"] { width:100%; }
  .row input[type="number"], .row select { width:100%; padding:6px; background:#0f1526; border:1px solid #28365a; color:#e6eef8; border-radius:6px; }
  .buttons { display:flex; gap:8px; flex-wrap:wrap; }
  button { padding:8px 10px; border-radius:8px; border:1px solid #33466f; background:#13203a; color:#e6eef8; cursor:pointer; }
  button.primary { border-color:#4a83ff; background:#1a2f5c; }
  .hint { font-size:12px; color:#9fb4db; margin-top:6px; }
  #chartWrap { position:absolute; left:12px; bottom:12px; width:520px; background:#0d1322c0; border:1px solid #1a2235; border-radius:8px; padding:8px; backdrop-filter: blur(4px); }
  #chart { width:100%; height:140px; display:block; background:#0c111d; border-radius:6px; }
  #legend { display:flex; gap:12px; font-size:12px; margin:6px 2px 0; color:#c9d8f4; opacity:.9; }
  #legend span::before { content:""; display:inline-block; width:10px; height:10px; margin-right:6px; border-radius:2px; vertical-align:baseline; }
  #legK::before { background:#6fc2ff; }
  #legU::before { background:#f6d06f; }
  #legT::before { background:#a9f56f; }
  #metrics { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; line-height:1.35; white-space:pre-wrap; }
  canvas { display:block; }
  #glCanvas { position:absolute; inset:0; }
  #trailCanvas { position:absolute; inset:0; pointer-events:none; }
</style>
</head>
<body>
<div id="topbar">
  <div id="title">N-Body Playground by Steve Cullen and ChatGPT (v2.2.0-offline)</div>
  <div id="status">Booting…</div>
</div>

<div id="app">
  <div id="left" class="panel">
    <h2>Setup</h2>
    <div class="group">
      <div class="row"><label>Stars (N)</label><input id="nStars" type="range" min="50" max="2000" step="50" value="800"><input id="nStarsNum" type="number" min="50" max="2000" step="50" value="800"></div>
      <div class="row"><label>Init radius (AU)</label><input id="radiusAU" type="range" min="0.2" max="50" step="0.1" value="6"><input id="radiusAUNum" type="number" min="0.2" max="50" step="0.1" value="6"></div>
      <div class="row"><label>Init velocity (km/s)</label><input id="initV" type="range" min="0" max="80" step="1" value="0"><input id="initVNum" type="number" min="0" max="80" step="1" value="0"></div>
      <div class="row"><label>Star mass min (M☉)</label><input id="mMin" type="range" min="1e-6" max="1" step="1e-6" value="5e-5"><input id="mMinNum" type="number" step="1e-6" value="5e-5"></div>
      <div class="row"><label>Star mass max (M☉)</label><input id="mMax" type="range" min="1e-6" max="5" step="1e-6" value="1e-3"><input id="mMaxNum" type="number" step="1e-6" value="1e-3"></div>
    </div>

    <h2>Central Star</h2>
    <div class="group">
      <div class="row"><label>Mass (M☉)</label><input id="mCentral" type="range" min="0.1" max="50" step="0.1" value="1"><input id="mCentralNum" type="number" min="0.1" max="50" step="0.1" value="1"></div>
      <div class="row"><label>Glow</label>
        <select id="glowMode">
          <option value="off">Off</option>
          <option value="on" selected>On</option>
        </select>
        <input id="glowIntensity" type="range" min="0" max="1" step="0.01" value="0.6">
      </div>
    </div>

    <h2>Collisions</h2>
    <div class="group">
      <div class="row"><label>Collision mode</label>
        <select id="collisionMode">
          <option value="none" selected>None</option>
          <option value="elastic">Elastic</option>
          <option value="merge">Merge</option>
        </select>
      </div>
      <div class="row"><label>Softening (ε AU)</label><input id="softening" type="range" min="0" max="0.2" step="0.001" value="0.01"><input id="softeningNum" type="number" min="0" max="0.2" step="0.001" value="0.01"></div>
    </div>

    <h2>Trails</h2>
    <div class="group">
      <div class="row"><label>Preset</label>
        <select id="trailPreset">
          <option value="none">None</option>
          <option value="short">Short</option>
          <option value="long" selected>Long</option>
          <option value="ultra">Ultra</option>
        </select>
      </div>
      <div class="row"><label>Persistence (s)</label><input id="trailSeconds" type="range" min="0" max="60" step="1" value="20"><input id="trailSecondsNum" type="number" min="0" max="60" step="1" value="20"></div>
    </div>

    <div class="buttons">
      <button id="btnReset">Reset</button>
      <button id="btnStart" class="primary">Start</button>
      <button id="btnPause">Pause</button>
      <button id="btnClear">Clear Trails</button>
      <button id="btnAutoFit">Auto Fit</button>
    </div>

    <div class="hint">Trackball: drag=rotate (LMB), pan (RMB), wheel=zoom.</div>
  </div>

  <div id="viewport">
    <canvas id="glCanvas"></canvas>
    <canvas id="trailCanvas"></canvas>
    <div id="chartWrap">
      <canvas id="chart"></canvas>
      <div id="legend"><span id="legK">Kinetic</span><span id="legU">Potential</span><span id="legT">Total</span></div>
    </div>
  </div>

  <div id="right" class="panel">
    <h2>Metrics</h2>
    <div class="group"><div id="metrics">—</div></div>
  </div>
</div>

<script>
(function(){
  const statusEl = document.getElementById('status');
  function setStatus(t,err){ statusEl.textContent=t; statusEl.style.color=err?'#ff7b7b':''; }

  const glCanvas = document.getElementById('glCanvas');
  const trailCanvas = document.getElementById('trailCanvas');
  const chartCanvas = document.getElementById('chart');
  const chartCtx = chartCanvas.getContext('2d');
  const metricsEl = document.getElementById('metrics');

  const AU = 1.496e11, MSUN = 1.989e30, G = 6.67430e-11;
  const $ = id => document.getElementById(id);

  const state = {
    n: parseInt($('nStars').value,10),
    radiusAU: parseFloat($('radiusAU').value),
    initV_kms: parseFloat($('initV').value),
    mMinMSun: parseFloat($('mMin').value),
    mMaxMSun: parseFloat($('mMax').value),
    softAU: parseFloat($('softening').value),
    collisionMode: $('collisionMode').value,
    trailSeconds: parseFloat($('trailSeconds').value),
    glow: $('glowMode').value==='on',
    glowIntensity: parseFloat($('glowIntensity').value),
    running:false, timeScale:1500, subDt:0.02
  };
  let centralMass = parseFloat($('mCentral').value)*MSUN;

  function link(rangeId, numId, cb){
    const r=$(rangeId), n=$(numId);
    function sync(fr){ if(fr) n.value=r.value; else r.value=n.value; cb(parseFloat(r.value)); }
    r.addEventListener('input',()=>sync(true)); n.addEventListener('input',()=>sync(false)); sync(true);
  }
  link('nStars','nStarsNum', v=>state.n=v|0);
  link('radiusAU','radiusAUNum', v=>state.radiusAU=v);
  link('initV','initVNum', v=>state.initV_kms=v);
  link('mMin','mMinNum', v=>state.mMinMSun=v);
  link('mMax','mMaxNum', v=>state.mMaxMSun=v);
  link('softening','softeningNum', v=>state.softAU=v);
  $('collisionMode').addEventListener('change', e=>state.collisionMode=e.target.value);
  $('trailPreset').addEventListener('change', e=>{ const map={none:0,short:6,long:20,ultra:45}; const v=map[e.target.value]; $('trailSeconds').value=v; $('trailSecondsNum').value=v; state.trailSeconds=v; });
  $('glowMode').addEventListener('change', e=>{ state.glow = e.target.value==='on'; });
  $('glowIntensity').addEventListener('input', e=>{ state.glowIntensity=parseFloat(e.target.value); });
  link('mCentral','mCentralNum', v=>{ centralMass=v*MSUN; });

  $('btnStart').onclick=()=>state.running=true;
  $('btnPause').onclick=()=>state.running=false;
  $('btnReset').onclick=()=>resetSystem();
  $('btnAutoFit').onclick=()=>autoFit();
  $('btnClear').onclick=()=>{ tctx.clearRect(0,0,trailCanvas.width, trailCanvas.height); };

  const gl = glCanvas.getContext('webgl', { antialias:true });
  if(!gl){ setStatus('❌ WebGL not supported', true); return; }
  const tctx = trailCanvas.getContext('2d');

  function resizeAll(){
    const vp = document.getElementById('viewport');
    const w = vp.clientWidth||1, h=vp.clientHeight||1;
    gl.canvas.width=w; gl.canvas.height=h; gl.viewport(0,0,w,h);
    trailCanvas.width=w; trailCanvas.height=h;
    const dpr = Math.min(devicePixelRatio,2);
    const chartW=520, chartH=140; chartCanvas.width=chartW*dpr; chartCanvas.height=chartH*dpr; chartCanvas.style.width=chartW+'px'; chartCanvas.style.height=chartH+'px';
  } window.addEventListener('resize', resizeAll); resizeAll();

  const vs = `
  attribute vec3 aPos; attribute float aSize; attribute vec3 aColor;
  uniform mat4 uProj, uView; varying vec3 vColor;
  void main(){
    vColor = aColor;
    gl_Position = uProj * uView * vec4(aPos,1.0);
    gl_PointSize = aSize / max(gl_Position.w, 0.0001);
  }`;
  const fs = `
  precision mediump float; varying vec3 vColor;
  uniform float uGlow;
  void main(){
    vec2 p = gl_PointCoord*2.0-1.0;
    float r = dot(p,p);
    if(r>1.0) discard;
    float core = smoothstep(1.0, 0.5, 1.0 - r);
    float glow = exp(-r*3.0) * uGlow;
    gl_FragColor = vec4(vColor*(0.6+glow), core*(0.85+0.15*uGlow));
  }`;
  function csh(src,t){ const s=gl.createShader(t); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)); return s; }
  function prog(vsSrc, fsSrc){ const p=gl.createProgram(); gl.attachShader(p,csh(vsSrc,gl.VERTEX_SHADER)); gl.attachShader(p,csh(fsSrc,gl.FRAGMENT_SHADER)); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p)); return p; }
  const prg = prog(vs,fs); gl.useProgram(prg);
  const loc = {
    aPos: gl.getAttribLocation(prg,'aPos'),
    aSize: gl.getAttribLocation(prg,'aSize'),
    aColor: gl.getAttribLocation(prg,'aColor'),
    uProj: gl.getUniformLocation(prg,'uProj'),
    uView: gl.getUniformLocation(prg,'uView'),
    uGlow: gl.getUniformLocation(prg,'uGlow')
  };

  // Minimal mat4 + trackball
  function mat4(){ return new Float32Array(16); }
  function ident(m){ m.set([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); return m; }
  function perspective(fovy, aspect, near, far){ const f=1/Math.tan(fovy/2), nf=1/(near-far); const m=mat4();
    m[0]=f/aspect; m[5]=f; m[10]=(far+near)*nf; m[11]=-1; m[14]=(2*far*near)*nf; m[15]=0; return m; }
  function lookAt(eye, tgt, up){
    const z = norm(sub(eye,tgt));
    const x = norm(cross(up,z));
    const y = cross(z,x);
    const m = mat4();
    m[0]=x[0]; m[1]=y[0]; m[2]=z[0]; m[3]=0;
    m[4]=x[1]; m[5]=y[1]; m[6]=z[1]; m[7]=0;
    m[8]=x[2]; m[9]=y[2]; m[10]=z[2]; m[11]=0;
    m[12]=-dot(x,eye); m[13]=-dot(y,eye); m[14]=-dot(z,eye); m[15]=1;
    return m;
  }
  function v3(x,y,z){ return new Float32Array([x,y,z]); }
  function add(a,b){ return v3(a[0]+b[0],a[1]+b[1],a[2]+b[2]); }
  function sub(a,b){ return v3(a[0]-b[0],a[1]-b[1],a[2]-b[2]); }
  function muls(a,s){ return v3(a[0]*s,a[1]*s,a[2]*s); }
  function dot(a,b){ return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }
  function cross(a,b){ return v3(a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]); }
  function len(a){ return Math.hypot(a[0],a[1],a[2]); }
  function norm(a){ const l=len(a)||1; return v3(a[0]/l,a[1]/l,a[2]/l); }

  let target = v3(0,0,0), sphR=18, sphPhi=Math.PI/2.2, sphTheta=0.9;
  function camPos(){ return v3(
    target[0] + sphR*Math.sin(sphTheta)*Math.sin(sphPhi),
    target[1] + sphR*Math.cos(sphPhi),
    target[2] + sphR*Math.cos(sphTheta)*Math.sin(sphPhi)
  );}

  let stateM='none', sx=0, sy=0;
  glCanvas.addEventListener('contextmenu', e=>e.preventDefault());
  glCanvas.addEventListener('mousedown', e=>{ sx=e.clientX; sy=e.clientY; stateM = (e.button===2)?'pan':'rot'; });
  window.addEventListener('mouseup', ()=>stateM='none');
  window.addEventListener('mousemove', e=>{
    if(stateM==='none') return;
    const dx=e.clientX-sx, dy=e.clientY-sy; sx=e.clientX; sy=e.clientY;
    if(stateM==='rot'){ sphTheta -= dx*0.005; sphPhi += dy*0.005; sphPhi=Math.max(0.001,Math.min(Math.PI-0.001,sphPhi)); }
    else if(stateM==='pan'){ const r=sphR; target[0] += (-dx*0.002*r); target[1] += (dy*0.002*r); }
  });
  glCanvas.addEventListener('wheel', e=>{ e.preventDefault(); const f=Math.exp((e.deltaY>0?1:-1)*0.1); sphR = Math.max(2, sphR*f); }, {passive:false});

  // Buffers & data
  let N=state.n;
  let pos, vel, size, col, mass; // arrays
  const bPos = gl.createBuffer(), bSize = gl.createBuffer(), bCol = gl.createBuffer();

  function colorFromMass(mSun){
    const t = Math.max(0, Math.min(1, (Math.log10(mSun+1e-6)+6)/6 ));
    return [1.0, (0.7+0.25*t), (0.5+0.5*(1-t))];
  }
  function starRadiusFromMass(mkg){ const RSun=6.9634e8; const r=RSun*Math.pow(mkg/MSUN,0.8); return (r/AU)*12; }
  function centralRadiusAU(mkg){ const RSun=6.9634e8; const r=RSun*Math.pow(mkg/MSUN,0.8); return (r/AU)*20; }

  function resetSystem(){
    N = state.n;
    pos = new Float32Array((N+1)*3);
    vel = new Float32Array((N+1)*3);
    size= new Float32Array(N+1);
    col = new Float32Array((N+1)*3);
    mass= new Float32Array(N+1);
    // central
    pos[0]=0; pos[1]=0; pos[2]=0;
    size[0]=Math.max(6, Math.min(120, centralRadiusAU(centralMass)*140)); // px approx
    col[0]=1.0; col[1]=0.82; col[2]=0.48;
    mass[0]=centralMass;
    // stars
    const R = state.radiusAU * 1.0; // positions in AU
    for(let i=1;i<=N;i++){
      let x,y,z; do{ x=(Math.random()*2-1)*R; y=(Math.random()*2-1)*R; z=(Math.random()*2-1)*R; } while(x*x+y*y+z*z>R*R);
      const j=i*3; pos[j]=x; pos[j+1]=y; pos[j+2]=z;
      const m = (state.mMinMSun + Math.random()*(state.mMaxMSun-state.mMinMSun)) * MSUN; mass[i]=m;
      const rAU = Math.max(starRadiusFromMass(m)/AU, 0.002); // already in AU scaling; tiny minimum
      size[i]= Math.max(2, rAU*100); // pixels
      const c = colorFromMass(m/MSUN); col[3*i]=c[0]; col[3*i+1]=c[1]; col[3*i+2]=c[2];
      if(state.initV_kms!==0){
        const L = Math.hypot(x,y,z)||1; const ax=y/L, ay=-x/L, az=0;
        const v0 = state.initV_kms*1000;
        vel[j]=ax*v0; vel[j+1]=ay*v0; vel[j+2]=az*v0;
      }
    }
    upload();
    chartData.length=0;
    tctx.clearRect(0,0,trailCanvas.width, trailCanvas.height);
    autoFit();
  }

  function upload(){
    gl.bindBuffer(gl.ARRAY_BUFFER, bPos); gl.bufferData(gl.ARRAY_BUFFER, pos, gl.DYNAMIC_DRAW); gl.enableVertexAttribArray(loc.aPos); gl.vertexAttribPointer(loc.aPos,3,gl.FLOAT,false,0,0);
    gl.bindBuffer(gl.ARRAY_BUFFER, bSize); gl.bufferData(gl.ARRAY_BUFFER, size, gl.DYNAMIC_DRAW); gl.enableVertexAttribArray(loc.aSize); gl.vertexAttribPointer(loc.aSize,1,gl.FLOAT,false,0,0);
    gl.bindBuffer(gl.ARRAY_BUFFER, bCol); gl.bufferData(gl.ARRAY_BUFFER, col, gl.DYNAMIC_DRAW); gl.enableVertexAttribArray(loc.aColor); gl.vertexAttribPointer(loc.aColor,3,gl.FLOAT,false,0,0);
  }

  function autoFit(){ sphR = Math.max(8, state.radiusAU*3); sphPhi = Math.PI/2.4; sphTheta = 0.9; target=v3(0,0,0); }

  // Physics
  function stepPhysics(h){
    const eps2 = (state.softAU)*(state.softAU);
    const GM_AU = G*centralMass/(AU*AU*AU); // AU units
    for(let i=1;i<=N;i++){
      const j=i*3;
      const x=pos[j], y=pos[j+1], z=pos[j+2];
      const r2=x*x+y*y+z*z+eps2; const r=Math.sqrt(r2)||1;
      const ax = -GM_AU * x / (r2 * r);
      const ay = -GM_AU * y / (r2 * r);
      const az = -GM_AU * z / (r2 * r);
      vel[j]   += ax*h*AU; // convert back to m/s
      vel[j+1] += ay*h*AU;
      vel[j+2] += az*h*AU;
      pos[j]   += (vel[j]  * h)/AU;
      pos[j+1] += (vel[j+1]* h)/AU;
      pos[j+2] += (vel[j+2]* h)/AU;

      // bounce off central
      const cR = centralRadiusAU(centralMass);
      if(r<cR){
        const nx=x/r, ny=y/r, nz=z/r;
        const vn = vel[j]*nx + vel[j+1]*ny + vel[j+2]*nz;
        vel[j]   -= 2*vn*nx; vel[j+1]-=2*vn*ny; vel[j+2]-=2*vn*nz;
        pos[j]=nx*(cR*1.01); pos[j+1]=ny*(cR*1.01); pos[j+2]=nz*(cR*1.01);
      }
    }
    if(state.collisionMode!=='none'){
      for(let i=1;i<=N;i++) for(let k=i+1;k<=N;k++){
        const ia=i*3, ka=k*3;
        const dx=pos[ia]-pos[ka], dy=pos[ia+1]-pos[ka+1], dz=pos[ia+2]-pos[ka+2];
        const d = Math.hypot(dx,dy,dz); const Ri=size[i]/120, Rk=size[k]/120;
        if(d < (Ri+Rk)){
          if(state.collisionMode==='elastic'){
            const nx=dx/(d||1), ny=dy/(d||1), nz=dz/(d||1);
            const va = vel[ia]*nx+vel[ia+1]*ny+vel[ia+2]*nz;
            const vb = vel[ka]*nx+vel[ka+1]*ny+vel[ka+2]*nz;
            const ma=mass[i], mb=mass[k];
            const va2=(va*(ma-mb)+2*mb*vb)/(ma+mb);
            const vb2=(vb*(mb-ma)+2*ma*va)/(ma+mb);
            const dva=va2-va, dvb=vb2-vb;
            vel[ia]+=dva*nx; vel[ia+1]+=dva*ny; vel[ia+2]+=dva*nz;
            vel[ka]+=dvb*nx; vel[ka+1]+=dvb*ny; vel[ka+2]+=dvb*nz;
          } else if(state.collisionMode==='merge'){
            const ma=mass[i], mb=mass[k]; const m=ma+mb;
            const vax=vel[ia], vay=vel[ia+1], vaz=vel[ia+2];
            const vbx=vel[ka], vby=vel[ka+1], vbz=vel[ka+2];
            vel[ia]=(vax*ma+vbx*mb)/m; vel[ia+1]=(vay*ma+vby*mb)/m; vel[ia+2]=(vaz*ma+vbz*mb)/m;
            mass[i]=m;
            // hide k
            pos[ka]=pos[ka+1]=pos[ka+2]=1e9;
          }
        }
      }
    }
  }

  // Energy chart
  let chartData=[]; const chartMax=600;
  function sampleEnergy(){
    let K=0, U=0;
    for(let i=1;i<=N;i++){
      const j=i*3; const vx=vel[j], vy=vel[j+1], vz=vel[j+2]; const m=mass[i];
      K += 0.5*m*(vx*vx+vy*vy+vz*vz);
      const r = Math.hypot(pos[j],pos[j+1],pos[j+2])*AU;
      U += -G*centralMass*m/Math.max(r,1);
    }
    chartData.push([K,U,K+U]); if(chartData.length>chartMax) chartData.shift();
  }
  function drawChart(){
    const dpr=Math.min(devicePixelRatio,2); const w=chartCanvas.width,h=chartCanvas.height;
    chartCtx.clearRect(0,0,w,h); if(chartData.length<2) return;
    const K=chartData.map(d=>d[0]), U=chartData.map(d=>d[1]), T=chartData.map(d=>d[2]);
    const minY=Math.min(...K,...U,...T), maxY=Math.max(...K,...U,...T);
    const pad=10*dpr; const xs=(w-2*pad)/(chartData.length-1);
    const mapY=v=> h - pad - (v-minY)/(maxY-minY+1e-9)*(h-2*pad);
    function series(arr, col){ chartCtx.beginPath(); chartCtx.lineWidth=2*dpr; chartCtx.strokeStyle=col; chartCtx.moveTo(pad,mapY(arr[0])); for(let i=1;i<arr.length;i++) chartCtx.lineTo(pad+i*xs,mapY(arr[i])); chartCtx.stroke(); }
    series(K,'#6fc2ff'); series(U,'#f6d06f'); series(T,'#a9f56f');
  }

  // Trails
  function renderTrails(dt){
    const w=trailCanvas.width, h=trailCanvas.height;
    if(state.trailSeconds<=0){ tctx.clearRect(0,0,w,h); return; }
    const decay=Math.max(0,1 - dt*(1/state.trailSeconds));
    tctx.globalCompositeOperation='source-over'; tctx.fillStyle='rgba(13,19,34,'+(1-decay)+')'; tctx.fillRect(0,0,w,h);
    tctx.globalCompositeOperation='lighter';
    // project
    const proj = perspective(Math.PI/3, gl.canvas.width/gl.canvas.height, 0.01, 5000.0);
    const eye = camPos(); const view = lookAt(eye, target, v3(0,1,0));
    function project(x,y,z){
      const vx = view[0]*x + view[4]*y + view[8]*z + view[12];
      const vy = view[1]*x + view[5]*y + view[9]*z + view[13];
      const vz = view[2]*x + view[6]*y + view[10]*z + view[14];
      const vw = view[3]*x + view[7]*y + view[11]*z + view[15];
      const px = proj[0]*vx + proj[4]*vy + proj[8]*vz + proj[12]*vw;
      const py = proj[1]*vx + proj[5]*vy + proj[9]*vz + proj[13]*vw;
      const pw = proj[3]*vx + proj[7]*vy + proj[11]*vz + proj[15]*vw;
      return [ (px/pw*0.5+0.5)*w, (-py/pw*0.5+0.5)*h ];
    }
    for(let i=1;i<=N;i++){ const j=i*3; const p=project(pos[j],pos[j+1],pos[j+2]); tctx.fillStyle='rgba(180,200,255,'+(0.3+0.6*state.glowIntensity)+')'; tctx.fillRect(p[0],p[1],1.5,1.5); }
  }

  function updateMetrics(){
    let sumR=0,sumV=0; for(let i=1;i<=N;i++){ const j=i*3; sumR+=Math.hypot(pos[j],pos[j+1],pos[j+2]); sumV+=Math.hypot(vel[j],vel[j+1],vel[j+2]); }
    metricsEl.textContent = [
      'Version: v2.2.0-offline',
      'Bodies: '+N,
      'Central Mass: '+(centralMass/MSUN).toFixed(3)+' M\u2609',
      'Avg radius: '+(sumR/Math.max(1,N)).toFixed(3)+' AU',
      'Avg speed: '+(sumV/Math.max(1,N)/1000).toFixed(3)+' km/s',
      'Collision: '+state.collisionMode,
      'Softening ε: '+state.softAU.toFixed(3)+' AU',
      'Glow: '+(state.glow?('On ('+state.glowIntensity.toFixed(2)+')'):'Off')
    ].join('\n');
  }

  function render(){
    const proj = perspective(Math.PI/3, gl.canvas.width/gl.canvas.height, 0.01, 5000.0);
    const eye = camPos(); const view = lookAt(eye, target, v3(0,1,0));
    gl.useProgram(prg);
    gl.uniformMatrix4fv(loc.uProj,false,proj);
    gl.uniformMatrix4fv(loc.uView,false,view);
    gl.uniform1f(loc.uGlow, state.glow? state.glowIntensity: 0.0);
    gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.clearColor(0.043,0.059,0.086,1); gl.clear(gl.COLOR_BUFFER_BIT);
    upload();
    gl.drawArrays(gl.POINTS, 0, N+1);
  }

  // Hook buttons
  function animate(){
    requestAnimationFrame(animate);
    const now=performance.now(); animate._last = animate._last||now; const dt=(now-animate._last)/1000; animate._last=now;
    if(state.running){
      const sim = dt*state.timeScale; const steps=Math.max(1, Math.ceil(sim/state.subDt)); const h=sim/steps;
      for(let s=0;s<steps;s++) stepPhysics(h);
      sampleEnergy();
    }
    render(); renderTrails(dt); drawChart(); updateMetrics();
    setStatus('✅ Ready — hit Start');
  }

  function init(){
    resetSystem();
    animate();
  }

  init();
})();
</script>
</body>
</html>
